## Mysql知识点

```
group by : 含有group by 中的select 语句， select 后面只能是 group by 字段和聚合函数
```



## 01查找最晚入职员工的所有信息

> 题目描述
>
> 查找最晚入职员工的所有信息
> CREATE TABLE `employees` (
> `emp_no` int(11) NOT NULL,
> `birth_date` date NOT NULL,
> `first_name` varchar(14) NOT NULL,
> `last_name` varchar(16) NOT NULL,
> `gender` char(1) NOT NULL,
> `hire_date` date NOT NULL,
> PRIMARY KEY (`emp_no`));
>

输出描述:

```
emp_nobirth_datefirst_namelast_namegenderhire_date
10008 1958-02-19 Saniya Kalloufi M 1994-09-15
```

```
SELECT * FROM employees ORDER BY hire_date DESC LIMIT 0,1
SELECT * FROM employees ORDER BY hire_date DESC LIMIT 1 //limit有两个参数，省略第一个默认为0
```



## 02查找入职员工时间排名倒数第三的员工所有信息

##### 题目描述

查找入职员工时间排名倒数第三的员工所有信息
CREATE TABLE `employees` (
`emp_no` int(11) NOT NULL,
`birth_date` date NOT NULL,
`first_name` varchar(14) NOT NULL,
`last_name` varchar(16) NOT NULL,
`gender` char(1) NOT NULL,
`hire_date` date NOT NULL,
PRIMARY KEY (`emp_no`));

##### 输出描述:

```
emp_no birth_date first_name last_name gender hire_date
10005 1955-01-21 Kyoichi Maliniak M 1989-09-12
```

```
SELECT * FROM employees ORDER BY hire_date DESC LIMIT 2,1
```



## 03查找各个部门当前(to_date='9999-01-01')领导当前薪水详情以及其对应部门编号dept_no

##### 题目描述

查找各个部门当前(to_date='9999-01-01')领导当前薪水详情以及其对应部门编号dept_no
CREATE TABLE `dept_manager` (
`dept_no` char(4) NOT NULL,
`emp_no` int(11) NOT NULL,
`from_date` date NOT NULL,
`to_date` date NOT NULL,
PRIMARY KEY (`emp_no`,`dept_no`));
CREATE TABLE `salaries` (
`emp_no` int(11) NOT NULL,
`salary` int(11) NOT NULL,
`from_date` date NOT NULL,
`to_date` date NOT NULL,
PRIMARY KEY (`emp_no`,`from_date`));

##### 输出描述:

```
emp_no salary from_date to_date dept_no
```



```
SELECT s.emp_no, s.salary, s.from_date, s.to_date , d.dept_no
FROM salaries s INNER JOIN dept_manager d
ON d.emp_no = s.emp_no
WHERE d.to_date='9999-01-01' AND s.to_date='9999-01-01'//必须以salaries表为主表, 薪水详情，表示salaries中的from_date to_date和另一张表不同，所以必须用salaries中的数据
```



## 04查找所有已经分配部门的员工的last_name和first_name

##### 题目描述

CREATE TABLE `dept_emp` (
`emp_no` int(11) NOT NULL,
`dept_no` char(4) NOT NULL,
`from_date` date NOT NULL,
`to_date` date NOT NULL,
PRIMARY KEY (`emp_no`,`dept_no`));
CREATE TABLE `employees` (
`emp_no` int(11) NOT NULL,
`birth_date` date NOT NULL,
`first_name` varchar(14) NOT NULL,
`last_name` varchar(16) NOT NULL,
`gender` char(1) NOT NULL,
`hire_date` date NOT NULL,
PRIMARY KEY (`emp_no`));

##### 输出描述:

```
last_name first_name dept_no
```

- code

```
SELECT employees.last_name,employees.first_name,dept_emp.dept_no
FROM employees INNER JOIN dept_emp
ON employees.`emp_no`=dept_emp.emp_no
//=>2
SELECT e.last_name, e.first_name, d.dept_no FROM employees e INNER JOIN dept_emp d
ON e.emp_no = d.emp_no
```



## 05查找所有员工的last_name和first_name以及对应部门编号dept_no，也包括展示没有分配具体部门的员工

##### 题目描述

查找所有员工的last_name和first_name以及对应部门编号dept_no，也包括展示没有分配具体部门的员工

CREATE TABLE `dept_emp` (
`emp_no` int(11) NOT NULL,
`dept_no` char(4) NOT NULL,
`from_date` date NOT NULL,
`to_date` date NOT NULL,
PRIMARY KEY (`emp_no`,`dept_no`));
CREATE TABLE `employees` (
`emp_no` int(11) NOT NULL,
`birth_date` date NOT NULL,
`first_name` varchar(14) NOT NULL,
`last_name` varchar(16) NOT NULL,
`gender` char(1) NOT NULL,
`hire_date` date NOT NULL,
PRIMARY KEY (`emp_no`));

##### 输出描述

```
last_name first_name dept_no
```

- code

```
select employees.last_name, employees.first_name ,dept_emp.dept_no
from employees left join dept_emp
on dept_emp.emp_no =employees.emp_no
//=>2
SELECT e.last_name, e.first_name, d.dept_no FROM employees e LEFT JOIN dept_emp d
ON e.emp_no = d.emp_no
```



## 06查找所有员工入职时候的薪水情况

##### 题目描述

查找所有员工入职时候的薪水情况，给出emp_no以及salary， 并按照emp_no进行逆序
CREATE TABLE `employees` (
`emp_no` int(11) NOT NULL,
`birth_date` date NOT NULL,
`first_name` varchar(14) NOT NULL,
`last_name` varchar(16) NOT NULL,
`gender` char(1) NOT NULL,
`hire_date` date NOT NULL,
PRIMARY KEY (`emp_no`)); 
CREATE TABLE `salaries` (
`emp_no` int(11) NOT NULL,
`salary` int(11) NOT NULL,
`from_date` date NOT NULL,
`to_date` date NOT NULL,
PRIMARY KEY (`emp_no`,`from_date`));



##### 输出描述:

```
emp_no salary
```

- code

```
SELECT e.emp_no, s.salary FROM employees AS e INNER JOIN salaries AS s
ON e.emp_no = s.emp_no AND e.hire_date = s.from_date
ORDER BY e.emp_no DESC  //注意：各个表字段中有重名字段，需要指定表名
//=>2
SELECT e.emp_no, s.salary FROM employees e INNER JOIN salaries s  
ON e.emp_no = s.emp_no AND e.hire_date = s.from_date  
ORDER BY e.emp_no DESC
```



## 07查找薪水涨幅超过15次的员工号emp_no以及其对应的涨幅次数

## 题目描述

查找薪水涨幅超过15次的员工号emp_no以及其对应的涨幅次数t
CREATE TABLE `salaries` (
`emp_no` int(11) NOT NULL,
`salary` int(11) NOT NULL,
`from_date` date NOT NULL,
`to_date` date NOT NULL,
PRIMARY KEY (`emp_no`,`from_date`));

###### 输出描述：

```
emp_no	t

10001   17
```

```
select emp_no, count(emp_no) as t
from salaries 
group by emp_no 
having t>15
//=>2
SELECT emp_no, COUNT(from_date) t FROM salaries GROUP BY emp_no HAVING t>=15
```





## 08找出所有员工当前薪水salary情况

###### 题目描述

找出所有员工当前(to_date='9999-01-01')具体的薪水salary情况，对于相同的薪水只显示一次,并按照逆序显示
CREATE TABLE `salaries` (
`emp_no` int(11) NOT NULL,
`salary` int(11) NOT NULL,
`from_date` date NOT NULL,
`to_date` date NOT NULL,
PRIMARY KEY (`emp_no`,`from_date`));

```
salary
94692
```

```
select distinct salary 
from salaries 
where to_date='9999-01-01'
order by salary desc

//=>2
SELECT DISTINCT salary FROM salaries WHERE to_date='9999-01-01' ORDER BY salary DESC 
```



## 09获取所有部门当前manager的当前薪水情况，给出dept_no, emp_no以及salary，当前表示

###### 题目描述

获取所有部门当前manager的当前薪水情况，给出dept_no, emp_no以及salary，当前表示to_date='9999-01-01'
CREATE TABLE `dept_manager` (
`dept_no` char(4) NOT NULL,
`emp_no` int(11) NOT NULL,
`from_date` date NOT NULL,
`to_date` date NOT NULL,
PRIMARY KEY (`emp_no`,`dept_no`));
CREATE TABLE `salaries` (
`emp_no` int(11) NOT NULL,
`salary` int(11) NOT NULL,
`from_date` date NOT NULL,
`to_date` date NOT NULL,
PRIMARY KEY (`emp_no`,`from_date`));



###### 输出描述:

```
dept_no emp_nos alary
d001     10002  72527
```

```
SELECT dept_no,dept_manager.emp_no,salary
FROM salaries,dept_manager
WHERE salaries.emp_no=dept_manager.emp_no
and salaries.to_date='9999-01-01'
and dept_manager.to_date='9999-01-01'

//=>2 注意点：1.部门当前manager  2.当前薪水
SELECT d.dept_no, d.emp_no, s.salary FROM dept_manager d INNER JOIN salaries s
ON d.emp_no=s.emp_no AND s.to_date='9999-01-01' AND d.to_date='9999-01-01'
```





## 10获取所有非manager的员工emp_no

###### 题目描述

获取所有非manager的员工emp_no
CREATE TABLE `dept_manager` (
`dept_no` char(4) NOT NULL,
`emp_no` int(11) NOT NULL,
`from_date` date NOT NULL,
`to_date` date NOT NULL,
PRIMARY KEY (`emp_no`,`dept_no`));
CREATE TABLE `employees` (
`emp_no` int(11) NOT NULL,
`birth_date` date NOT NULL,
`first_name` varchar(14) NOT NULL,
`last_name` varchar(16) NOT NULL,
`gender` char(1) NOT NULL,
`hire_date` date NOT NULL,
PRIMARY KEY (`emp_no`));



###### 输出描述:

```
emp_no

10001
```



```
select employees.emp_no 
from employees left join dept_manager
on employees.emp_no = dept_manager.emp_no
WHERE dept_no IS NULL
//=>2  只要含有左边的值，最后加where
SELECT e.emp_no FROM employees  e LEFT JOIN dept_manager d  ON  e.emp_no= d.emp_no 
WHERE d.dept_no IS NULL 
```



## 11获取所有员工当前的manager

获取所有员工当前的manager，如果当前的manager是自己的话结果不显示，当前表示to_date='9999-01-01'。
结果第一列给出当前员工的emp_no,第二列给出其manager对应的manager_no。
CREATE TABLE `dept_emp` (
`emp_no` int(11) NOT NULL,
`dept_no` char(4) NOT NULL,
`from_date` date NOT NULL,
`to_date` date NOT NULL,
PRIMARY KEY (`emp_no`,`dept_no`));
CREATE TABLE `dept_manager` (
`dept_no` char(4) NOT NULL,
`emp_no` int(11) NOT NULL,
`from_date` date NOT NULL,
`to_date` date NOT NULL,
PRIMARY KEY (`emp_no`,`dept_no`));

###### 输出描述:

```
emp_no manager_no

10001   10002
```



```
SELECT de.emp_no, dm.emp_no AS manager_no 
FROM dept_emp AS de INNER JOIN dept_manager AS dm
ON de.dept_no = dm.dept_no 
WHERE dm.to_date = '9999-01-01' AND de.to_date = '9999-01-01' AND de.emp_no <> dm.emp_no
//=>2   注意点：当前manager是自己的话不显示，两张表，员工表的emp_no==manager表的emp_no，就过滤
SELECT de.emp_no, dm.emp_no AS manager_no FROM dept_emp de INNER JOIN dept_manager dm 
ON de.dept_no=dm.dept_no AND dm.to_date='9999-01-01' AND de.emp_no <> dm.emp_no
```





## 12获取所有部门中当前员工薪水最高的相关信息

###### 题目描述

获取所有部门中当前员工薪水最高的相关信息，给出dept_no, emp_no以及其对应的salary
CREATE TABLE `dept_emp` (
`emp_no` int(11) NOT NULL,
`dept_no` char(4) NOT NULL,
`from_date` date NOT NULL,
`to_date` date NOT NULL,
PRIMARY KEY (`emp_no`,`dept_no`));
CREATE TABLE `salaries` (
`emp_no` int(11) NOT NULL,
`salary` int(11) NOT NULL,
`from_date` date NOT NULL,
`to_date` date NOT NULL,
PRIMARY KEY (`emp_no`,`from_date`));



###### 输出描述:

```
dept_no emp_no salary

d001    10001     88958
```

- code

```
select dept_no, dept_emp.emp_no, max(salary)
from dept_emp inner join salaries
on dept_emp.emp_no = salaries.emp_no
and dept_emp.to_date = '9999-01-01' and salaries.to_date='9999-01-01'
group by dept_no
//=>2 
# 1. 最高薪水  2.当前员工  3.薪水当前时间   4.以结果来看，要查找的是部门中薪水最高的
SELECT de.dept_no, de.emp_no, MAX(s.salary)  FROM dept_emp de INNER JOIN salaries s
ON  s.emp_no =de.emp_no AND de.to_date='9999-01-01' AND s.to_date='9999-01-01'  GROUP BY dept_no
```



## 13从titles表获取按照title进行分组

###### 题目描述

从titles表获取按照title进行分组，每组个数大于等于2，给出title以及对应的数目t。
CREATE TABLE IF NOT EXISTS "titles" (
`emp_no` int(11) NOT NULL,
`title` varchar(50) NOT NULL,
`from_date` date NOT NULL,
`to_date` date DEFAULT NULL);

###### 输出描述:

```
title				t
Assistant Engineer  2
Engineer			4
```

```
SELECT title , COUNT(*) AS t FROM titles GROUP BY title HAVING t>=2

//=>2 注意点： count(实质上也是用emp_no 人的个数进行统计count的)
SELECT title , COUNT(emp_no) AS t FROM titles GROUP BY title HAVING t>=2  
```



## 14从titles表获取按照title进行分组，注意对于重复的emp_no进行忽略。

###### 题目描述

从titles表获取按照title进行分组，每组个数大于等于2，给出title以及对应的数目t。
注意对于重复的emp_no进行忽略。
CREATE TABLE IF NOT EXISTS "titles" (
`emp_no` int(11) NOT NULL,
`title` varchar(50) NOT NULL,
`from_date` date NOT NULL,
`to_date` date DEFAULT NULL);



###### 输出描述:

```
title					t

Assistant Engineer		2
Engineer				3
```

```sql
SELECT title, COUNT(DISTINCT emp_no) AS t 
FROM titles
GROUP BY title HAVING t >= 2
//=>2   注意点：count(函数中可以添加distinct进行去重)
SELECT title, COUNT(DISTINCT emp_no_ t FROM titles GROUP BY title HAVING t>=2
```



## 15查找employees表

###### 题目描述

查找employees表所有emp_no为奇数，且last_name不为Mary的员工信息，并按照hire_date逆序排列
CREATE TABLE `employees` (
`emp_no` int(11) NOT NULL,
`birth_date` date NOT NULL,
`first_name` varchar(14) NOT NULL,
`last_name` varchar(16) NOT NULL,
`gender` char(1) NOT NULL,
`hire_date` date NOT NULL,
PRIMARY KEY (`emp_no`));

###### 输出描述:

```
emp_no birth_date first_name last_name gender hire_date

10011 1953-11-07     Mary    Sluis       F    1990-01-22
```

```sql
select * from employees 
where not emp_no %2 =0 
and 
    last_name != 'Mary'
order by hire_date desc
//=>2
SELECT * FROM employees WHERE emp_no %2 =1  AND last_name != 'Mary'
ORDER BY hire_date DESC
```



## 16统计出当前各个title类型对应的员工当前薪水对应的平均工资

###### 题目描述

统计出当前各个title类型对应的员工当前薪水对应的平均工资。结果给出title以及平均工资avg。
CREATE TABLE `salaries` (
`emp_no` int(11) NOT NULL,
`salary` int(11) NOT NULL,
`from_date` date NOT NULL,
`to_date` date NOT NULL,
PRIMARY KEY (`emp_no`,`from_date`));
CREATE TABLE IF NOT EXISTS "titles" (
`emp_no` int(11) NOT NULL,
`title` varchar(50) NOT NULL,
`from_date` date NOT NULL,
`to_date` date DEFAULT NULL);



###### 输出描述:

```
title			avg	
Engineer		94409.0
Senior Engineer	69009.2
```

```
SELECT titles.title, AVG(salary) as avg
FROM salaries INNER JOIN titles
ON salaries.`emp_no` = titles.emp_no
AND salaries.`to_date`='9999-01-01'
and titles.to_date='9999-01-01'
GROUP BY title 
//=>2  总结：看到表中有时间日期的要考虑不同时间的因素和维度
SELECT t.title , AVG(salary) FROM salaries s INNER JOIN  titles t
ON t.emp_no = s.emp_no  AND t.to_date='9999-01-01' AND  s.to_date='9999-01-01' GROUP BY title
```



## 17获取当前薪水第二多的员工的emp_no以及其对应的薪水salary

###### 题目描述

获取当前（to_date='9999-01-01'）薪水第二多的员工的emp_no以及其对应的薪水salary
CREATE TABLE `salaries` (
`emp_no` int(11) NOT NULL,
`salary` int(11) NOT NULL,
`from_date` date NOT NULL,
`to_date` date NOT NULL,
PRIMARY KEY (`emp_no`,`from_date`));

###### 输出描述:

```
emp_no	salary
10009	94409
```

```
select emp_no, salary
from salaries
where to_date='9999-01-01'
order by salary desc
limit 1,1

//=>2
SELECT emp_no, salary FROM salaries WHERE to_date='9999-01-01' ORDER BY salary DESC LIMIT 1,1
```



## 18获取当前薪水第二多的员工的emp_no以及其对应的薪水salary，不准使用order by

###### 题目描述

查找当前薪水(to_date='9999-01-01')排名第二多的员工编号emp_no、薪水salary、last_name以及first_name，不准使用order by
CREATE TABLE `employees` (
`emp_no` int(11) NOT NULL,
`birth_date` date NOT NULL,
`first_name` varchar(14) NOT NULL,
`last_name` varchar(16) NOT NULL,
`gender` char(1) NOT NULL,
`hire_date` date NOT NULL,
PRIMARY KEY (`emp_no`));
CREATE TABLE `salaries` (
`emp_no` int(11) NOT NULL,
`salary` int(11) NOT NULL,
`from_date` date NOT NULL,
`to_date` date NOT NULL,
PRIMARY KEY (`emp_no`,`from_date`));



###### 输出描述:

```
emp_no	salary	last_name	first_name
10009	94409	Peac		Sumant
```

- code

```
select e.emp_no,max(s.salary),e.last_name,e.first_name 
from employees e, salaries s
where s.salary < (select max(salary) from salaries)
and s.to_date="9999-01-01" 
and e.emp_no=s.emp_no;

//=>2  思路： 先求出最高薪资，然后取出比最高薪资小，并且是最高的薪资
SELECT e.emp_no, MAX(s.salary), last_name, first_name
FROM employees e INNER JOIN salaries s ON e.emp_no = s.emp_no
AND  s.salary < (SELECT MAX(salary) FROM salaries)
AND s.to_date='9999-01-01'
```



## 19查找所有员工的last_name和first_name以及对应的dept_name

###### 题目描述

查找所有员工的last_name和first_name以及对应的dept_name，也包括暂时没有分配部门的员工
CREATE TABLE `departments` (
`dept_no` char(4) NOT NULL,
`dept_name` varchar(40) NOT NULL,
PRIMARY KEY (`dept_no`));
CREATE TABLE `dept_emp` (
`emp_no` int(11) NOT NULL,
`dept_no` char(4) NOT NULL,
`from_date` date NOT NULL,
`to_date` date NOT NULL,
PRIMARY KEY (`emp_no`,`dept_no`));
CREATE TABLE `employees` (
`emp_no` int(11) NOT NULL,
`birth_date` date NOT NULL,
`first_name` varchar(14) NOT NULL,
`last_name` varchar(16) NOT NULL,
`gender` char(1) NOT NULL,
`hire_date` date NOT NULL,
PRIMARY KEY (`emp_no`));



###### 输出描述:

```
last_name	first_name	dept_name
Facello		Georgi		Marketing
```

- code

```
SELECT last_name, first_name, departments.dept_name 
FROM employees 
left join dept_emp 
on employees.emp_no=dept_emp.emp_no
left join departments on departments.dept_no = dept_emp.dept_no

//=>2  三种表之间只要能够通过每个表的外键字段建立联系即可
SELECT e.last_name, e.first_name, d.dept_name FROM employees e LEFT JOIN  dept_emp de
ON e.emp_no = de.emp_no 
LEFT JOIN departments d
ON d.dept_no = de.dept_no
```





## 20查找员工编号emp_no为10001其自入职以来的薪水salary涨幅值growth

###### 题目描述

查找员工编号emp_no为10001其自入职以来的薪水salary涨幅值growth
CREATE TABLE `salaries` (
`emp_no` int(11) NOT NULL,
`salary` int(11) NOT NULL,
`from_date` date NOT NULL,
`to_date` date NOT NULL,
PRIMARY KEY (`emp_no`,`from_date`));

###### 输出描述:

```
growth
28841
```

```
select 
(select salary from salaries where emp_no=10001 order by salary desc limit 1)
-
(select salary from salaries where emp_no=10001 order by salary asc limit 1)
as growth

//=>2
#1.最高工资-最低工资  2.as的作用范围  3.编号emp_no =10001
SELECT (MAX(salary)-MIN(salary)) AS growth 
FROM salaries WHERE emp_no = '10001'
```





## 21查找所有员工自入职以来的薪水涨幅情况

###### 题目描述

查找所有员工自入职以来的薪水涨幅情况，给出员工编号emp_no以及其对应的薪水涨幅growth，并按照growth进行升序
CREATE TABLE `employees` (
`emp_no` int(11) NOT NULL,
`birth_date` date NOT NULL,
`first_name` varchar(14) NOT NULL,
`last_name` varchar(16) NOT NULL,
`gender` char(1) NOT NULL,
`hire_date` date NOT NULL,
PRIMARY KEY (`emp_no`));
CREATE TABLE `salaries` (
`emp_no` int(11) NOT NULL,
`salary` int(11) NOT NULL,
`from_date` date NOT NULL,
`to_date` date NOT NULL,
PRIMARY KEY (`emp_no`,`from_date`));



###### 输出描述:

```
emp_no	growth

10011	0
```



```sql
select cur.emp_no, 
(cur.salary-st.salary) as growth
from (select e.emp_no, s.salary from employees e , salaries s where e.emp_no=s.emp_no and s.to_date= '9999-01-01') as cur,
(select e.emp_no, s.salary from employees e, salaries s where e.emp_no=s.emp_no and s.from_date=e.hire_date) as st
where cur.emp_no = st.emp_no
order by growth
//=>2 首先查询当前时间的薪水  查询雇佣时间的薪水
SELECT cur.emp_no, (cur.salary-st.salary) AS growth 
  FROM 
  ( SELECT s.emp_no, s.salary FROM salaries AS s WHERE to_date= '9999-01-01'  ) AS cur INNER JOIN 
  (SELECT e.emp_no, s.salary FROM salaries s INNER JOIN employees e ON s.emp_no = e.emp_no AND e.hire_date = s.from_date) AS st
ON cur.emp_no = st.emp_no 
ORDER BY growth 
```



## 22统计各个部门对应员工涨幅的次数总和

###### 题目描述

统计各个部门对应员工涨幅的次数总和，给出部门编码dept_no、部门名称dept_name以及次数sum
CREATE TABLE `departments` (
`dept_no` char(4) NOT NULL,
`dept_name` varchar(40) NOT NULL,
PRIMARY KEY (`dept_no`));
CREATE TABLE `dept_emp` (
`emp_no` int(11) NOT NULL,
`dept_no` char(4) NOT NULL,
`from_date` date NOT NULL,
`to_date` date NOT NULL,
PRIMARY KEY (`emp_no`,`dept_no`));
CREATE TABLE `salaries` (
`emp_no` int(11) NOT NULL,
`salary` int(11) NOT NULL,
`from_date` date NOT NULL,
`to_date` date NOT NULL,
PRIMARY KEY (`emp_no`,`from_date`));



###### 输出描述:

```
dept_no		dept_name	sum

d001		Marketing	24
d002		Finance		14
```

```sql

select d.dept_no ,dept.dept_name,count(salary) from salaries s ,dept_emp d,departments dept
where s.emp_no = d.emp_no and d.dept_no=dept.dept_no group by dept.dept_no
//=>2 就是因为数据库字段具有二义性，不知道是哪个表中的字段导致的问题
SELECT d.dept_no, d.dept_name, COUNT(salary) AS `sum` 
FROM departments d INNER JOIN dept_emp de
ON d.dept_no=de.dept_no
INNER JOIN salaries s 
ON de.emp_no = s.emp_no 
GROUP BY d.dept_no
```





## 23对所有员工的薪水按照salary进行按照1-N的排名

###### 题目描述

对所有员工的当前(to_date='9999-01-01')薪水按照salary进行按照1-N的排名，相同salary并列且按照emp_no升序排列
CREATE TABLE `salaries` (
`emp_no` int(11) NOT NULL,
`salary` int(11) NOT NULL,
`from_date` date NOT NULL,
`to_date` date NOT NULL,
PRIMARY KEY (`emp_no`,`from_date`));



###### 输出描述:

```
emp_no	salary	rank

10005	94692	1
```

```sql
SELECT s1.emp_no, s1.salary, COUNT(DISTINCT s2.salary) AS rank
FROM salaries AS s1, salaries AS s2
WHERE s1.to_date = '9999-01-01'  AND s2.to_date = '9999-01-01' AND s1.salary <= s2.salary
GROUP BY s1.emp_no
ORDER BY s1.salary DESC, s1.emp_no ASC

//=>2  使用嵌套查询方式，内层查询比外层工资高的个数，类似两层循环
SELECT a.emp_no, a.salary, (
SELECT COUNT(DISTINCT b.salary) FROM salaries b WHERE b.to_date='9999-01-01' AND b.salary >a.salary
)+1 AS rank
FROM salaries a WHERE a.to_date='9999-01-01'
GROUP BY emp_no
ORDER BY salary DESC, emp_no
```



## 24获取所有非manager员工当前的薪水情况

###### 题目描述

获取所有非manager员工当前的薪水情况，给出dept_no、emp_no以及salary ，当前表示to_date='9999-01-01'
CREATE TABLE `dept_emp` (
`emp_no` int(11) NOT NULL,
`dept_no` char(4) NOT NULL,
`from_date` date NOT NULL,
`to_date` date NOT NULL,
PRIMARY KEY (`emp_no`,`dept_no`));
CREATE TABLE `dept_manager` (
`dept_no` char(4) NOT NULL,
`emp_no` int(11) NOT NULL,
`from_date` date NOT NULL,
`to_date` date NOT NULL,
PRIMARY KEY (`emp_no`,`dept_no`));
CREATE TABLE `employees` (
`emp_no` int(11) NOT NULL,
`birth_date` date NOT NULL,
`first_name` varchar(14) NOT NULL,
`last_name` varchar(16) NOT NULL,
`gender` char(1) NOT NULL,
`hire_date` date NOT NULL,
PRIMARY KEY (`emp_no`));
CREATE TABLE `salaries` (
`emp_no` int(11) NOT NULL,
`salary` int(11) NOT NULL,
`from_date` date NOT NULL,
`to_date` date NOT NULL,
PRIMARY KEY (`emp_no`,`from_date`));



###### 输出描述:

```
dept_no	emp_no	salary

d001	10001	88958
d004	10003	43311
d005	10007	88070
```



```sql
select d.dept_no,d.emp_no,s.salary 
from dept_emp d inner join salaries s
on d.emp_no = s.emp_no 
where d.to_date= '9999-01-01' and s.to_date='9999-01-01' 
and d.emp_no not in (select emp_no from dept_manager ) 
//=>2
SELECT de.dept_no, de.emp_no, s.salary 
FROM dept_emp de INNER JOIN dept_manager dm
ON de.dept_no=dm.dept_no AND de.emp_no != dm.emp_no
INNER JOIN salaries s 
ON de.emp_no=s.emp_no AND s.to_date='9999-01-01'
```



## 25获取员工其当前的薪水比其manager当前薪水还高的相关信息

###### 题目描述

获取员工其当前的薪水比其manager当前薪水还高的相关信息，当前表示to_date='9999-01-01',
结果第一列给出员工的emp_no，
第二列给出其manager的manager_no，
第三列给出该员工当前的薪水emp_salary,
第四列给该员工对应的manager当前的薪水manager_salary
CREATE TABLE `dept_emp` (
`emp_no` int(11) NOT NULL,
`dept_no` char(4) NOT NULL,
`from_date` date NOT NULL,
`to_date` date NOT NULL,
PRIMARY KEY (`emp_no`,`dept_no`));
CREATE TABLE `dept_manager` (
`dept_no` char(4) NOT NULL,
`emp_no` int(11) NOT NULL,
`from_date` date NOT NULL,
`to_date` date NOT NULL,
PRIMARY KEY (`emp_no`,`dept_no`));
CREATE TABLE `salaries` (
`emp_no` int(11) NOT NULL,
`salary` int(11) NOT NULL,
`from_date` date NOT NULL,
`to_date` date NOT NULL,
PRIMARY KEY (`emp_no`,`from_date`));



###### 输出描述:

```
emp_no	manager_no	emp_salary	manager_salary

10001	10002		88958		72527
10009	10010		95409		94409
```

```sql
SELECT a.emp_no AS emp_no, b.emp_no AS manager_no, a.salary AS emp_salary, b.salary AS manager_salary
FROM (SELECT s.salary, s.emp_no, de.dept_no FROM salaries s INNER JOIN dept_emp de
ON s.emp_no = de.emp_no AND s.to_date = '9999-01-01' ) AS a, 
(SELECT s.salary, s.emp_no, dm.dept_no FROM salaries s INNER JOIN dept_manager dm
ON s.emp_no = dm.emp_no AND s.to_date = '9999-01-01' ) AS b
WHERE a.dept_no = b.dept_no AND a.salary > b.salary

//=>2 分成小问题处理，先求员工，再求经理，然后根据条件join，比较薪水
SELECT  se.emp_no AS emp_no, sm.emp_no AS manager_no, se.salary AS emp_salary, sm.salary AS manager_salary
FROM 
(
SELECT  de.emp_no,de.dept_no, s.salary FROM salaries s 
INNER JOIN dept_emp de ON s.emp_no = de.emp_no AND s.to_date='9999-01-01'
AND de.to_date='9999-01-01'
) AS se
INNER JOIN
(
SELECT dm.emp_no,dm.dept_no, s.salary FROM dept_manager dm 
INNER JOIN salaries s ON s.emp_no=dm.emp_no 
AND s.to_date='9999-01-01' AND dm.to_date='9999-01-01'
) AS sm
ON se.dept_no = sm.dept_no
WHERE se.salary >sm.salary
```



## 26汇总各个部门当前员工的title类型的分配数目

###### 题目描述

汇总各个部门当前员工的title类型的分配数目，结果给出部门编号dept_no、dept_name、其当前员工所有的title以及该类型title对应的数目count
CREATE TABLE `departments` (
`dept_no` char(4) NOT NULL,
`dept_name` varchar(40) NOT NULL,
PRIMARY KEY (`dept_no`));
CREATE TABLE `dept_emp` (
`emp_no` int(11) NOT NULL,
`dept_no` char(4) NOT NULL,
`from_date` date NOT NULL,
`to_date` date NOT NULL,
PRIMARY KEY (`emp_no`,`dept_no`));
CREATE TABLE IF NOT EXISTS `titles` (
`emp_no` int(11) NOT NULL,
`title` varchar(50) NOT NULL,
`from_date` date NOT NULL,
`to_date` date DEFAULT NULL);



###### 输出描述:

```
dept_no	dept_name	title			count

d001	Marketing	Senior Engineer	1
d001	Marketing	Staff			1
```

- code

```sql
select de.dept_no,dp.dept_name,t.title,count(t.title) as `count`
from departments dp inner join dept_emp de
on dp.dept_no = de.dept_no and de.to_date='9999-01-01'
inner join titles t
on t.emp_no = de.emp_no and t.to_date = '9999-01-01'
group by de.dept_no,t.title

//=>2
SELECT de.dept_no, dm.dept_name, t.title, COUNT(*)  AS `count`
FROM dept_emp de INNER JOIN 
departments dm ON de.dept_no = dm.dept_no AND de.to_date='9999-01-01'
INNER JOIN titles t ON t.emp_no = de.emp_no AND t.to_date='9999-01-01'
GROUP BY de.dept_no, t.title
```





## 27给出每个员工每年薪水涨幅超过5000的员工编号emp_no

###### 题目描述

给出每个员工每年薪水涨幅超过5000的员工编号emp_no、薪水变更开始日期from_date以及薪水涨幅值salary_growth，并按照salary_growth逆序排列。

提示：在sqlite中获取datetime时间对应的年份函数为strftime('%Y', to_date)

CREATE TABLE `salaries` (

`emp_no` int(11) NOT NULL,

`salary` int(11) NOT NULL,

`from_date` date NOT NULL,

`to_date` date NOT NULL,

PRIMARY KEY (`emp_no`,`from_date`));



###### 输出描述:

```
emp_no	from_date	salary_growth
10003	1995-12-03	24178
10008	1998-03-11	20843
```

- code

```sql
select s1.emp_no, s1.from_date, (s1.salary-s2.salary) salary_growth
from salaries s1 
inner join salaries s2
on s1.emp_no = s2.emp_no
where s1.salary -s2.salary>5000
and strftime('%Y', s1.to_date) -strftime('%Y', s2.to_date)=1
order by salary_growth desc;

//=>2 to_date
SELECT s1.emp_no, s1.from_date, (s1.salary-s2.salary) AS salary_growth
FROM salaries s1
INNER JOIN salaries s2
ON s1.emp_no = s2.emp_no
AND s1.salary-s2.salary>5000
AND strftime('%Y', s1.to_date) - strftime('%Y', s2.to_date) =1
ORDER BY salary_growth DESC;
```





## 28查找描述信息中包括robot的电影对应的分类名称以及电影数目，而且还需要该分类对应电影数量

###### 题目描述

film表

| 字段        | 说明         |
| ----------- | ------------ |
| film_id     | 电影id       |
| title       | 电影名称     |
| description | 电影描述信息 |

> CREATE TABLE IF NOT EXISTS film (
>
> film_id smallint(5)  NOT NULL DEFAULT '0',
>
> title varchar(255) NOT NULL,
>
> description text,
>
> PRIMARY KEY (film_id));

category表

| 字段        | 说明                 |
| ----------- | -------------------- |
| category_id | 电影分类id           |
| name        | 电影分类名称         |
| last_update | 电影分类最后更新时间 |

> CREATE TABLE category  (
>
> category_id  tinyint(3)  NOT NULL ,
>
> name  varchar(25) NOT NULL, `last_update` timestamp,
>
> PRIMARY KEY ( category_id ));

film_category表

| 字段        | 说明                                 |
| ----------- | ------------------------------------ |
| film_id     | 电影id                               |
| category_id | 电影分类id                           |
| last_update | 电影id和分类id对应关系的最后更新时间 |

> CREATE TABLE film_category  (
>
> film_id  smallint(5)  NOT NULL,
>
> category_id  tinyint(3)  NOT NULL, `last_update` timestamp);



查找描述信息中包括robot的电影对应的分类名称以及电影数目，而且还需要该分类对应电影数量>=5部



```sql
select c.name,count(fc.film_id)
from (
    select category_id,count(category_id)
    from film_category
    group by category_id
    having count(category_id)>=5
)as cc,
film_category fc,
category c,
film f
where f.description like '%robot%'
and f.film_id = fc.film_id
AND c.category_id = fc.category_id
AND c.category_id = cc.category_id;
```





## 29使用join查询方式找出没有分类的电影id以及名称

###### 题目描述

film表

| 字段        | 说明         |
| ----------- | ------------ |
| film_id     | 电影id       |
| title       | 电影名称     |
| description | 电影描述信息 |

> CREATE TABLE IF NOT EXISTS film (
>
> film_id smallint(5)  NOT NULL DEFAULT '0',
>
> title varchar(255) NOT NULL,
>
> description text,
>
> PRIMARY KEY (film_id));

category表

| 字段        | 说明                 |
| ----------- | -------------------- |
| category_id | 电影分类id           |
| name        | 电影分类名称         |
| last_update | 电影分类最后更新时间 |

> CREATE TABLE category  (
>
> category_id  tinyint(3)  NOT NULL ,
>
> name  varchar(25) NOT NULL, `last_update` timestamp,
>
> PRIMARY KEY ( category_id ));

film_category表

| 字段        | 说明                                 |
| ----------- | ------------------------------------ |
| film_id     | 电影id                               |
| category_id | 电影分类id                           |
| last_update | 电影id和分类id对应关系的最后更新时间 |

> CREATE TABLE film_category  (
>
> film_id  smallint(5)  NOT NULL,
>
> category_id  tinyint(3)  NOT NULL, `last_update` timestamp);



使用join查询方式找出没有分类的电影id以及名称



```sql
select f.film_id, f.title
from film f
left join film_category c
on f.film_id = c.film_id
where c.category_id is null;
```





## 29使用子查询的方式找出属于Action分类的所有电影对应的title,description

###### 题目描述

film表

| 字段        | 说明         |
| ----------- | ------------ |
| film_id     | 电影id       |
| title       | 电影名称     |
| description | 电影描述信息 |

> CREATE TABLE IF NOT EXISTS film (
>
> film_id smallint(5)  NOT NULL DEFAULT '0',
>
> title varchar(255) NOT NULL,
>
> description text,
>
> PRIMARY KEY (film_id));

category表

| 字段        | 说明                 |
| ----------- | -------------------- |
| category_id | 电影分类id           |
| name        | 电影分类名称         |
| last_update | 电影分类最后更新时间 |

> CREATE TABLE category  (
>
> category_id  tinyint(3)  NOT NULL ,
>
> name  varchar(25) NOT NULL, `last_update` timestamp,
>
> PRIMARY KEY ( category_id ));

film_category表

| 字段        | 说明                                 |
| ----------- | ------------------------------------ |
| film_id     | 电影id                               |
| category_id | 电影分类id                           |
| last_update | 电影id和分类id对应关系的最后更新时间 |

> CREATE TABLE film_category  (
>
> film_id  smallint(5)  NOT NULL,
>
> category_id  tinyint(3)  NOT NULL, `last_update` timestamp);



使用子查询的方式找出属于Action分类的所有电影对应的title,description



```
select f.title,f.description
from film  f 
inner join film_category fc on f.film_id=fc.film_id
inner join category c on c.category_id= fc.category_id
where c.name = 'Action'
```



## 30获取select * from employees对应的执行计划

```
explain select * from employees
```





## 31将employees表的所有员工的last_name和first_name拼接起来作为Name

###### 题目描述

将employees表的所有员工的last_name和first_name拼接起来作为Name，中间以一个空格区分
CREATE TABLE `employees` ( `emp_no` int(11) NOT NULL,
`birth_date` date NOT NULL,
`first_name` varchar(14) NOT NULL,
`last_name` varchar(16) NOT NULL,
`gender` char(1) NOT NULL,
`hire_date` date NOT NULL,
PRIMARY KEY (`emp_no`));



###### 输出描述:

| name           |
| -------------- |
| Facello Georgi |
| Simmel Bezalel |
| Bamford Parto  |

- code

```
select last_name||" "||first_name AS Name FROM employees;
```





## 32创建一个actor表，包含如下列信息

## 题目描述

创建一个actor表，包含如下列信息

| 列表        | 类型        | 是否为NULL | 含义                               |
| ----------- | ----------- | ---------- | ---------------------------------- |
| actor_id    | smallint(5) | not null   | 主键id                             |
| first_name  | varchar(45) | not null   | 名字                               |
| last_name   | varchar(45) | not null   | 姓氏                               |
| last_update | timestamp   | not null   | 最后更新时间，默认是系统的当前时间 |



- cod

```
create table actor(
actor_id smallint(5) not null PRIMARY key,
first_name varchar(45) not null ,
last_name varchar(45) not null,
last_update timestamp not null DEFAULT (datetime('now','localtime')) 
)
```



## 33批量插入数据

###### 题目描述

对于表actor批量插入如下数据

CREATE TABLE IF NOT EXISTS actor (

actor_id smallint(5) NOT NULL PRIMARY KEY,

first_name varchar(45) NOT NULL,

last_name varchar(45) NOT NULL,

last_update timestamp NOT NULL DEFAULT (datetime('now','localtime')))

| actor_id | first_name | last_name | last_update         |
| -------- | ---------- | --------- | ------------------- |
| 1        | PENELOPE   | GUINESS   | 2006-02-15 12:34:33 |
| 2        | NICK       | WAHLBERG  | 2006-02-15 12:34:33 |

- code

```sql
insert into actor
values(1,'PENELOPE','GUINESS','2006-02-15 12:34:33'),(2,'NICK','WAHLBERG','2006-02-15 12:34:33');
```



## 34批量插入数据，不使用replace操作

## 题目描述

对于表actor批量插入如下数据,如果数据已经存在，请忽略，不使用replace操作

CREATE TABLE IF NOT EXISTS actor (

actor_id smallint(5) NOT NULL PRIMARY KEY,

first_name varchar(45) NOT NULL,

last_name varchar(45) NOT NULL,

last_update timestamp NOT NULL DEFAULT (datetime('now','localtime')))

| actor_id | first_name | last_name | last_update           |
| -------- | ---------- | --------- | --------------------- |
| '3'      | 'ED'       | 'CHASE'   | '2006-02-15 12:34:33' |

- code

```
insert or ignore into actor
values('3','ED','CHASE','2006-02-15 12:34:33')
```



## 35创建一个actor_name表

###### 题目描述

对于如下表actor，其对应的数据为:

| actor_id | first_name | last_name | last_update         |
| -------- | ---------- | --------- | ------------------- |
| 1        | PENELOPE   | GUINESS   | 2006-02-15 12:34:33 |
| 2        | NICK       | WAHLBERG  | 2006-02-15 12:34:33 |

创建一个actor_name表，将actor表中的所有first_name以及last_name导入改表。 actor_name表结构如下：

| 列表       | 类型        | 是否为NULL | 含义 |
| ---------- | ----------- | ---------- | ---- |
| first_name | varchar(45) | not null   | 名字 |
| last_name  | varchar(45) | not null   | 姓氏 |



- code

```
create table actor_name as
select first_name,last_name from actor
```



## 36对first_name创建唯一索引uniq_idx_firstname

###### 题目描述

针对如下表actor结构创建索引：
CREATE TABLE IF NOT EXISTS actor (
actor_id smallint(5) NOT NULL PRIMARY KEY,
first_name varchar(45) NOT NULL,
last_name varchar(45) NOT NULL,
last_update timestamp NOT NULL DEFAULT (datetime('now','localtime')))
对first_name创建唯一索引uniq_idx_firstname，对last_name创建普通索引idx_lastname

- code

```
create unique index uniq_idx_firstname on actor(first_name);
create index idx_lastname on actor(last_name)
```



## 37针对actor表创建视图actor_name_view

> 针对actor表创建视图actor_name_view，只包含first_name以及last_name两列，并对这两列重新命名，first_name为first_name_v，last_name修改为last_name_v：
> CREATE TABLE IF NOT EXISTS actor (
> actor_id smallint(5) NOT NULL PRIMARY KEY,
> first_name varchar(45) NOT NULL,
> last_name varchar(45) NOT NULL,
> last_update timestamp NOT NULL DEFAULT (datetime('now','localtime')))

```
create view actor_name_view (first_name_v,last_name_v) as
select first_name,last_name from actor
```



## 38针对上面的salaries表emp_no字段创建索引idx_emp_no

> 题目描述：
>
> 针对salaries表emp_no字段创建索引idx_emp_no，查询emp_no为10005, 使用强制索引。
> CREATE TABLE `salaries` (
> `emp_no` int(11) NOT NULL,
> `salary` int(11) NOT NULL,
> `from_date` date NOT NULL,
> `to_date` date NOT NULL,
> PRIMARY KEY (`emp_no`,`from_date`));
> create index idx_emp_no on salaries(emp_no);



```sql
#sqlite
SELECT * FROM salaries INDEXED BY idx_emp_no WHERE emp_no = 10005
#mysql--查询时强制使用索引方式
SELECT * FROM salaries FORCE INDEX idx_emp_no WHERE emp_no = 10005
```

## 39在last_update后面新增加一列名字为create_date

> 题目描述：
>
> 存在actor表，包含如下列信息：
> CREATE TABLE IF NOT EXISTS actor (
> actor_id smallint(5) NOT NULL PRIMARY KEY,
> first_name varchar(45) NOT NULL,
> last_name varchar(45) NOT NULL,
> last_update timestamp NOT NULL DEFAULT (datetime('now','localtime')));
> 现在在last_update后面新增加一列名字为create_date, 类型为datetime, NOT NULL，默认值为'0000 00:00:00'

```
ALTER TABLE actor
ADD `create_date` DATETIME NOT NULL DEFAULT '0000-00-00 00:00:00'
```



## 40构造一个触发器audit_log



> 题目描述：
>
> 构造一个触发器audit_log，在向employees_test表中插入一条数据的时候，触发插入相关的数据到audit中。
> CREATE TABLE employees_test(
> ID INT PRIMARY KEY NOT NULL,
> NAME TEXT NOT NULL,
> AGE INT NOT NULL,
> ADDRESS CHAR(50),
> SALARY REAL
> );
> CREATE TABLE audit(
> EMP_no INT NOT NULL,
> NAME TEXT NOT NULL
> );

```
      
CREATE TRIGGER audit_log 
AFTER INSERT ON employees_test
BEGIN
    INSERT INTO audit VALUES(new.id,new.name);
END
```





## 41删除emp_no重复的记录，只保留最小的id对应的记录。

> 题目描述：
>
> 删除emp_no重复的记录，只保留最小的id对应的记录。
> CREATE TABLE IF NOT EXISTS titles_test (
> id int(11) not null primary key,
> emp_no int(11) NOT NULL,
> title varchar(50) NOT NULL,
> from_date date NOT NULL,
> to_date date DEFAULT NULL);
>
> insert into titles_test values ('1', '10001', 'Senior Engineer', '1986-06-26', '9999-01-01'),
> ('2', '10002', 'Staff', '1996-08-03', '9999-01-01'),
> ('3', '10003', 'Senior Engineer', '1995-12-03', '9999-01-01'),
> ('4', '10004', 'Senior Engineer', '1995-12-03', '9999-01-01'),
> ('5', '10001', 'Senior Engineer', '1986-06-26', '9999-01-01'),
> ('6', '10002', 'Staff', '1996-08-03', '9999-01-01'),
> ('7', '10003', 'Senior Engineer', '1995-12-03', '9999-01-01');

```
 DELETE FROM titles_test WHERE id NOT IN 
(SELECT MIN(id) FROM titles_test GROUP BY emp_no)
```



## 42将所有to_date为9999-01-01的全部更新为NULL

> 题目描述：
>
> 将所有to_date为9999-01-01的全部更新为NULL,且 from_date更新为2001-01-01。
> CREATE TABLE IF NOT EXISTS titles_test (
> id int(11) not null primary key,
> emp_no int(11) NOT NULL,
> title varchar(50) NOT NULL,
> from_date date NOT NULL,
> to_date date DEFAULT NULL);
>
> insert into titles_test values ('1', '10001', 'Senior Engineer', '1986-06-26', '9999-01-01'),
> ('2', '10002', 'Staff', '1996-08-03', '9999-01-01'),
> ('3', '10003', 'Senior Engineer', '1995-12-03', '9999-01-01'),
> ('4', '10004', 'Senior Engineer', '1995-12-03', '9999-01-01'),
> ('5', '10001', 'Senior Engineer', '1986-06-26', '9999-01-01'),
> ('6', '10002', 'Staff', '1996-08-03', '9999-01-01'),
> ('7', '10003', 'Senior Engineer', '1995-12-03', '9999-01-01');



```
UPDATE titles_test
SET to_date=NULL , from_date='2001-01-01'
WHERE to_date='9999-01-01'
```



## 43将id=5以及emp_no=10001的行数据替换成id=5以及emp_no=10005

>  将id=5以及emp_no=10001的行数据替换成id=5以及emp_no=10005,其他数据保持不变，使用replace实现。
> CREATE TABLE IF NOT EXISTS titles_test (
> id int(11) not null primary key,
> emp_no int(11) NOT NULL,
> title varchar(50) NOT NULL,
> from_date date NOT NULL,
> to_date date DEFAULT NULL);
>
> insert into titles_test values ('1', '10001', 'Senior Engineer', '1986-06-26', '9999-01-01'),
> ('2', '10002', 'Staff', '1996-08-03', '9999-01-01'),
> ('3', '10003', 'Senior Engineer', '1995-12-03', '9999-01-01'),
> ('4', '10004', 'Senior Engineer', '1995-12-03', '9999-01-01'),
> ('5', '10001', 'Senior Engineer', '1986-06-26', '9999-01-01'),
> ('6', '10002', 'Staff', '1996-08-03', '9999-01-01'),
> ('7', '10003', 'Senior Engineer', '1995-12-03', '9999-01-01');  



```
UPDATE `titles_test` SET `emp_no` = REPLACE
 (`emp_no`,'10001','10005') WHERE `id`=5
```



## 44将titles_test表名修改为titles_2017

> 题目描述
> 将titles_test表名修改为titles_2017。
> CREATE TABLE IF NOT EXISTS titles_test (
> id int(11) not null primary key,
> emp_no int(11) NOT NULL,
> title varchar(50) NOT NULL,
> from_date date NOT NULL,
> to_date date DEFAULT NULL);
>
> insert into titles_test values ('1', '10001', 'Senior Engineer', '1986-06-26', '9999-01-01'),
> ('2', '10002', 'Staff', '1996-08-03', '9999-01-01'),
> ('3', '10003', 'Senior Engineer', '1995-12-03', '9999-01-01'),
> ('4', '10004', 'Senior Engineer', '1995-12-03', '9999-01-01'),
> ('5', '10001', 'Senior Engineer', '1986-06-26', '9999-01-01'),
> ('6', '10002', 'Staff', '1996-08-03', '9999-01-01'),
> ('7', '10003', 'Senior Engineer', '1995-12-03', '9999-01-01');

```
ALTER TABLE titles_test RENAME TO titles_2017;
```



## 45在audit表上创建外键约束，其emp_no对应employees_test表的主键id

> 题目描述
>
> 在audit表上创建外键约束，其emp_no对应employees_test表的主键id。
> CREATE TABLE employees_test(
> ID INT PRIMARY KEY NOT NULL,
> NAME TEXT NOT NULL,
> AGE INT NOT NULL,
> ADDRESS CHAR(50),
> SALARY REAL
> );
>
> CREATE TABLE audit(
> EMP_no INT NOT NULL,
> create_date datetime NOT NULL
> );

```
1. mysql语法
#主表是参考的表是外键对应的表
ALTER TABLE audit
ADD  FOREIGN KEY(emp_no) REFERENCES employees_test(id)
2. sqlite方式
drop table audit;
CREATE TABLE audit(
    emp_no INT NOT NULL,
    create_date DATETIME NOT NULL,
    FOREIGN KEY(emp_no) REFERENCES employees_test(id));
```



## 46如何获取emp_v和employees有相同的数据no

> 题目描述：
>
> 存在如下的视图：
>
> create view emp_v as select * from employees where emp_no >10005;
>
> 如何获取emp_v和employees有相同的数据？
>
> CREATE TABLE `employees` (
>
> `emp_no` int(11) NOT NULL,
>
> `birth_date` date NOT NULL,
>
> `first_name` varchar(14) NOT NULL,
>
> `last_name` varchar(16) NOT NULL,
>
> `gender` char(1) NOT NULL,
>
> `hire_date` date NOT NULL,
>
> PRIMARY KEY (`emp_no`));



输出格式:

| emp_no | birth_date | first_name | last_name | gender | hire_date  |
| ------ | ---------- | ---------- | --------- | ------ | ---------- |
| 10006  | 1953-04-20 | Anneke     | Preusig   | F      | 1989-06-02 |
| 10007  | 1957-05-23 | Tzvetan    | Zielinski | F      | 1989-02-10 |





```
 SELECT * FROM employees WHERE emp_no >10005;
```







## 47将所有获取奖金的员工当前的薪水增加10%

> 题目描述:将所有获取奖金的员工当前的薪水增加10%。
> create table emp_bonus(
> emp_no int not null,
> recevied datetime not null,
> btype smallint not null);
> CREATE TABLE `salaries` (
> `emp_no` int(11) NOT NULL,
> `salary` int(11) NOT NULL,
> `from_date` date NOT NULL,
> `to_date` date NOT NULL, PRIMARY KEY (`emp_no`,`from_date`));



```
UPDATE salaries SET salary =salary*1.1
WHERE emp_no IN (SELECT emp_no FROM emp_bonus);
```



## 48针对库中的所有表生成select count(*)对应的SQL语句



```
#本题意义不大
SELECT "select count(*) from " || name || ";" AS cnts
FROM sqlite_master WHERE type = 'table'
```



## 49将employees表中的所有员工的last_name和first_name通过(')连接起来。

> 将employees表中的所有员工的last_name和first_name通过(')连接起来。
>
> CREATE TABLE `employees` (
>
> `emp_no` int(11) NOT NULL,
>
> `birth_date` date NOT NULL,
>
> `first_name` varchar(14) NOT NULL,
>
> `last_name` varchar(16) NOT NULL,
>
> `gender` char(1) NOT NULL,
>
> `hire_date` date NOT NULL,
>
> PRIMARY KEY (`emp_no`));
>
> 输出格式:

| name           |
| -------------- |
| Facello'Georgi |

```
#sqllite不支持拼接函数，所以比较恶心
SELECT last_name || "'" || first_name FROM employees

mysql：
SELECT CONCAT(last_name,"‘",first_name) AS NAME 
FROM employees;
```



## 50查找字符串'10,A,B' 中逗号','出现的次数cnt

> 题目描述
>
> 查找字符串'10,A,B' 中逗号','出现的次数cnt。

```
#mysql
SELECT LENGTH(SUBSTRING_INDEX('10,A,B',',',1))
#sqlite不支持函数
SELECT LENGTH("10,a,b") - LENGTH (REPLACE ("10,a,b",",",""));
```



## 51获取Employees中的first_name

> 题目描述：
>
> 获取Employees中的first_name，查询按照first_name最后两个字母，按照升序进行排列
>
> CREATE TABLE `employees` (
>
> `emp_no` int(11) NOT NULL,
>
> `birth_date` date NOT NULL,
>
> `first_name` varchar(14) NOT NULL,
>
> `last_name` varchar(16) NOT NULL,
>
> `gender` char(1) NOT NULL,
>
> `hire_date` date NOT NULL,
>
> PRIMARY KEY (`emp_no`));

输出格式：

| first_name |
| ---------- |
| Chirstian  |
| Tzvetan    |



```
#sqllite不支持right
SELECT first_name FROM employees ORDER BY RIGHT(first_name,2)

SELECT first_name FROM employees
ORDER BY SUBSTR(first_name,LENGTH(first_name)-1,2)
```



## 52按照dept_no进行汇总

> 按照dept_no进行汇总，属于同一个部门的emp_no按照逗号进行连接，结果给出dept_no以及连接出的结果employees
>
> CREATE TABLE `dept_emp` (
>
> `emp_no` int(11) NOT NULL,
>
> `dept_no` char(4) NOT NULL,
>
> `from_date` date NOT NULL,
>
> `to_date` date NOT NULL,
>
> PRIMARY KEY (`emp_no`,`dept_no`));
>
> 输出格式:

| dept_no | employees   |
| ------- | ----------- |
| d001    | 10001,10002 |

```sql
#按照组进行拼接
SELECT dept_no, GROUP_CONCAT(emp_no) AS employees
FROM dept_emp GROUP BY dept_no;
```



## 53查找排除当前最大、最小salary之后的员工的平均工资avg_salary

> 题目描述
> 查找排除当前最大、最小salary之后的员工的平均工资avg_salary。
> CREATE TABLE `salaries` (
> `emp_no` INT(11) NOT NULL,
> `salary` INT(11) NOT NULL,
> `from_date` DATE NOT NULL,
> `to_date` DATE NOT NULL,
> PRIMARY KEY (`emp_no`,`from_date`));
> 输出格式:
> avg_salary
> 69462.5555555556
>

```
SELECT AVG(salary) AS avg_salary FROM salaries
WHERE to_date='9999-01-01'
AND salary <> (SELECT MAX(salary) FROM salaries)
AND salary <> (SELECT MIN(salary) FROM salaries)
```







## 54分页查询employees表，每5行一页，返回第2页的数据

>
> 题目描述
> 分页查询employees表，每5行一页，返回第2页的数据
> CREATE TABLE `employees` (
> `emp_no` INT(11) NOT NULL,
> `birth_date` DATE NOT NULL,
> `first_name` VARCHAR(14) NOT NULL,
> `last_name` VARCHAR(16) NOT NULL,
> `gender` CHAR(1) NOT NULL,
> `hire_date` DATE NOT NULL,
> PRIMARY KEY (`emp_no`));

```
SELECT * FROM employees LIMIT 5,5
```



## 55获取所有员工的emp_no

> 获取所有员工的emp_no、部门编号dept_no以及对应的bonus类型btype和recevied，没有分配具体的员工不显示
>
> CREATE TABLE `dept_emp` (
> `emp_no` int(11) NOT NULL,
> `dept_no` char(4) NOT NULL,
> `from_date` date NOT NULL,
> `to_date` date NOT NULL,
> PRIMARY KEY (`emp_no`,`dept_no`));
>
> CREATE TABLE `dept_manager` (
> `dept_no` char(4) NOT NULL,
> `emp_no` int(11) NOT NULL,
> `from_date` date NOT NULL,
> `to_date` date NOT NULL,
> PRIMARY KEY (`emp_no`,`dept_no`));
>
> CREATE TABLE `employees` (
> `emp_no` int(11) NOT NULL,
> `birth_date` date NOT NULL,
> `first_name` varchar(14) NOT NULL,
> `last_name` varchar(16) NOT NULL,
> `gender` char(1) NOT NULL,
> `hire_date` date NOT NULL,
> PRIMARY KEY (`emp_no`));
>
> CREATE TABLE `salaries` (
> `emp_no` int(11) NOT NULL,
> `salary` int(11) NOT NULL,
> `from_date` date NOT NULL,
> `to_date` date NOT NULL,
> PRIMARY KEY (`emp_no`,`from_date`));
>
> create table emp_bonus(
> emp_no int not null,
> recevied datetime not null,
> btype smallint not null);
>
> 输出格式:
> e.emp_no	dept_no	btype	recevied
> 10001		d001	1	2010-01-01



```
SELECT e.emp_no, d.dept_no, eb.btype, eb.recevied
FROM employees AS e INNER JOIN dept_emp d ON e.emp_no = d.emp_no
LEFT JOIN emp_bonus  eb ON eb.emp_no=e.emp_no;
```





## 56获取所有员工的emp_no

> 获取所有员工的emp_no、部门编号dept_no以及对应的bonus类型btype和recevied，没有分配具体的员工不显示
> CREATE TABLE `dept_emp` ( `emp_no` int(11) NOT NULL,
> `dept_no` char(4) NOT NULL,
> `from_date` date NOT NULL,
> `to_date` date NOT NULL,
> PRIMARY KEY (`emp_no`,`dept_no`));
> CREATE TABLE `dept_manager` (
> `dept_no` char(4) NOT NULL,
> `emp_no` int(11) NOT NULL,
> `from_date` date NOT NULL,
> `to_date` date NOT NULL,
> PRIMARY KEY (`emp_no`,`dept_no`));
> CREATE TABLE `employees` (
> `emp_no` int(11) NOT NULL,
> `birth_date` date NOT NULL,
> `first_name` varchar(14) NOT NULL,
> `last_name` varchar(16) NOT NULL,
> `gender` char(1) NOT NULL,
> `hire_date` date NOT NULL,
> PRIMARY KEY (`emp_no`));
> CREATE TABLE `salaries` (
> `emp_no` int(11) NOT NULL,
> `salary` int(11) NOT NULL,
> `from_date` date NOT NULL,
> `to_date` date NOT NULL,
> PRIMARY KEY (`emp_no`,`from_date`));









## 57使用含有关键字exists查找未分配具体部门的员工的所有信息。

> 使用含有关键字exists查找未分配具体部门的员工的所有信息。
> CREATE TABLE `employees` (
> `emp_no` int(11) NOT NULL,
> `birth_date` date NOT NULL,
> `first_name` varchar(14) NOT NULL,
> `last_name` varchar(16) NOT NULL,
> `gender` char(1) NOT NULL,
> `hire_date` date NOT NULL,
> PRIMARY KEY (`emp_no`));
> CREATE TABLE `dept_emp` (
> `emp_no` int(11) NOT NULL,
> `dept_no` char(4) NOT NULL,
> `from_date` date NOT NULL,
> `to_date` date NOT NULL,
> PRIMARY KEY (`emp_no`,`dept_no`));

```
SELECT * FROM employees WHERE NOT EXISTS
(SELECT	emp_no FROM dept_emp WHERE emp_no =employees.emp_no);
```





## 58统计salary的累计和running_total

> 题目描述：
>
> 按照salary的累计和running_total，其中running_total为前两个员工的salary累计和，其他以此类推。 具体结果如下Demo展示。。

CREATE TABLE `salaries` ( `emp_no` int(11) NOT NULL,

`salary` int(11) NOT NULL,

`from_date` date NOT NULL,

`to_date` date NOT NULL,

PRIMARY KEY (`emp_no`,`from_date`));

输出格式:

| emp_no | salary | running_total |
| ------ | ------ | ------------- |
| 10001  | 88958  | 88958         |
| 10002  | 72527  | 161485        |
| 10003  | 43311  | 204796        |
| 10004  | 74057  | 278853        |
| 10005  | 94692  | 373545        |
| 10006  | 43311  | 416856        |
| 10007  | 88070  | 504926        |
| 10009  | 95409  | 600335        |



```sqlite
select s1.emp_no, s1.salary,  (select sum(s2.salary) from salaries as s2 where s2.emp_no<= s1.emp_no AND s2.to_date='9999-01-01'  ) as  running_total from 
salaries s1 where s1.to_date='9999-01-01' order by s1.emp_no 

```



## 59获取employees中的行数据，且这些行也在emp_v中

> 存在如下的视图：
> create view emp_v as select * from employees where emp_no >10005;
> CREATE TABLE `employees` (
> `emp_no` int(11) NOT NULL,
> `birth_date` date NOT NULL,
> `first_name` varchar(14) NOT NULL,
> `last_name` varchar(16) NOT NULL,
> `gender` char(1) NOT NULL,
> `hire_date` date NOT NULL,
> PRIMARY KEY (`emp_no`));
> 获取employees中的行数据，且这些行也存在于emp_v中。注意不能使用intersect关键字。

```
SELECT * FROM emp_v
```



## 60获取有奖金的员工相关信息。

> 获取有奖金的员工相关信息。
> CREATE TABLE `employees` (
> `emp_no` int(11) NOT NULL,
> `birth_date` date NOT NULL,
> `first_name` varchar(14) NOT NULL,
> `last_name` varchar(16) NOT NULL,
> `gender` char(1) NOT NULL,
> `hire_date` date NOT NULL,
> PRIMARY KEY (`emp_no`));
> CREATE TABLE `dept_emp` (
> `emp_no` int(11) NOT NULL,
> `dept_no` char(4) NOT NULL,
> `from_date` date NOT NULL,
> `to_date` date NOT NULL,
> PRIMARY KEY (`emp_no`,`dept_no`));
> create table emp_bonus(
> emp_no int not null,
> recevied datetime not null,
> btype smallint not null);
> CREATE TABLE `salaries` (
> `emp_no` int(11) NOT NULL,
> `salary` int(11) NOT NULL,
> `from_date` date NOT NULL,
> `to_date` date NOT NULL, PRIMARY KEY (`emp_no`,`from_date`));
> 给出emp_no、first_name、last_name、奖金类型btype、对应的当前薪水情况salary以及奖金金额bonus。 bonus类型btype为1其奖金为薪水salary的10%，btype为2其奖金为薪水的20%，其他类型均为薪水的30%。 当前薪水表示to_date='9999-01-01'



```
SELECT e.emp_no, e.first_name, e.last_name, b.btype , s.salary,
(
CASE b.btype 
WHEN 1 THEN s.salary*0.1
WHEN 2 THEN s.salary*0.2
ELSE s.salary*0.3 END
) AS bonus
from
employees e INNER JOIN emp_bonus b ON e.emp_no=b.emp_no INNER JOIN salaries s ON
s.emp_no=e.emp_no AND s.to_date = '9999-01-01';
```



## 61对于employees表中，给出奇数行的first_name

## 题目描述

> 对于employees表中，给出奇数行的first_name
>
> CREATE TABLE `employees` (
>
> `emp_no` int(11) NOT NULL,
>
> `birth_date` date NOT NULL,
>
> `first_name` varchar(14) NOT NULL,
>
> `last_name` varchar(16) NOT NULL,
>
> `gender` char(1) NOT NULL,
>
> `hire_date` date NOT NULL,
>
> PRIMARY KEY (`emp_no`));



输出格式:

| first_name |
| ---------- |
| Georgi     |
| Chirstian  |
| Anneke     |
| Tzvetan    |
| Saniya     |
| Mary       |

```sqlite
SELECT e1.first_name FROM 
  (SELECT e2.first_name, 
    (SELECT COUNT(*) FROM employees AS e3 
     WHERE e3.first_name <= e2.first_name) 
   AS rowid FROM employees AS e2) AS e1
WHERE e1.rowid % 2 = 1
```







# LeetCode database

## 175Combine Two Tables

> Write a SQL query for a report that provides the following information for each person in the Person table, regardless if there is an address for each of those people:

```
select Person.FirstName,Person.LastName,Address.City,Address.State
from Person
left  join Address
on Person.PersonId = Address.PersonId
//=>2
SELECT p.FirstName, p.LastName, a.City,a.State
FROM Person p LEFT JOIN Address a
ON p.PersonId=a.PersonId
```



## 176Second Highest Salary

> For example, given the above Employee table, the query should return `200` as the second highest salary. If there is no second highest salary, then the query should return `null`.

```
SELECT IFNULL(SELECT Salary FROM Employee GROUP BY Salary ORDER BY Salary DESC LIMIT 1,1),
NULL) AS SecondHighestSalary  //去除重复数据，薪资有相同的数据，所以以Salary进行分组
```



## 177 Nth Highest Salary

获取第n高的薪水

```
CREATE FUNCTION getNthHighestSalary(N INT) RETURNS INT
BEGIN
    DECLARE n1 INT;
    SET n1=N-1;  
  RETURN (
      SELECT Salary FROM 
      (SELECT DISTINCT Salary FROM Employee) t 
      ORDER BY Salary DESC 
      LIMIT n1,1

  );
END
```









## 其他

##### hql

> 订单表(t_order) (
>
> oid int 订单id
>
> uid int 用户id
>
> otime date 订单时间
>
> oamount int 订单金额
>
> ); --其中用户表和订单表是一对多的关系
>
> 要求：计算在18年1月份下过订单，2月份没有下过订单的用户在3月份的订单金额分布，输出结果形式： uid, 三月份订单金额超过10的订单数，3月份首次下单的金额，3月份最后一次下单的金额
>
> 要求： 对订单表查询不大于2次

```
select
uid,
sum(if(date_format(otime,'yyyy-MM')='2018-01',1,0)) jaucnt,
sum(if(date_format(otime,'yyyy-MM')='2018-02',1,0)) febcnt,
sum(if(date_format(otime,'yyyy-MM')='2018-03' and oamount>10 ,1,0)) marcnt,
sum(if(date_format(otime,'yyyy-MM')='2018-03' and ok.rk=1, oamount,0)) first, --三月份第一次下单金额
sum(if(date_format(otime,'yyyy-MM')='2018-03' and ok.rk=oc,oamount,0)) second --三月份最后一次下单金额
from (
select * , row_number() over(partition by date_format(otime,'yyyy-MM'),uid order by otime) rk,
count(*) over(partition by date_format(otime,'yyyy-MM'),uid) oc
from t_order
) ok
group by uid
having jaucnt>0 and febcnt=0
#总结： 1.起别名不能重复
2.开窗函数中 聚合函数() over(这个括号中添加聚合规则)
```

