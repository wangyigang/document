## 01查找最晚入职员工的所有信息

##### 题目描述

查找最晚入职员工的所有信息
CREATE TABLE `employees` (
`emp_no` int(11) NOT NULL,
`birth_date` date NOT NULL,
`first_name` varchar(14) NOT NULL,
`last_name` varchar(16) NOT NULL,
`gender` char(1) NOT NULL,
`hire_date` date NOT NULL,
PRIMARY KEY (`emp_no`));

##### 输出描述:

```
emp_nobirth_datefirst_namelast_namegenderhire_date
10008 1958-02-19 Saniya Kalloufi M 1994-09-15
```

```
SELECT * FROM employees ORDER BY hire_date DESC LIMIT 0,1
```



## 02查找入职员工时间排名倒数第三的员工所有信息

##### 题目描述

查找入职员工时间排名倒数第三的员工所有信息
CREATE TABLE `employees` (
`emp_no` int(11) NOT NULL,
`birth_date` date NOT NULL,
`first_name` varchar(14) NOT NULL,
`last_name` varchar(16) NOT NULL,
`gender` char(1) NOT NULL,
`hire_date` date NOT NULL,
PRIMARY KEY (`emp_no`));

##### 输出描述:

```
emp_no birth_date first_name last_name gender hire_date
10005 1955-01-21 Kyoichi Maliniak M 1989-09-12
```

```
SELECT * FROM employees ORDER BY hire_date DESC LIMIT 2,1
```



## 03查找各个部门当前(to_date='9999-01-01')领导当前薪水详情以及其对应部门编号dept_no

##### 题目描述

查找各个部门当前(to_date='9999-01-01')领导当前薪水详情以及其对应部门编号dept_no
CREATE TABLE `dept_manager` (
`dept_no` char(4) NOT NULL,
`emp_no` int(11) NOT NULL,
`from_date` date NOT NULL,
`to_date` date NOT NULL,
PRIMARY KEY (`emp_no`,`dept_no`));
CREATE TABLE `salaries` (
`emp_no` int(11) NOT NULL,
`salary` int(11) NOT NULL,
`from_date` date NOT NULL,
`to_date` date NOT NULL,
PRIMARY KEY (`emp_no`,`from_date`));

##### 输出描述:

```
emp_no salary from_date to_date dept_no
```



```
SELECT salaries.emp_no,salaries.salary,salaries.from_date,salaries.to_date,dept_manager.dept_no
FROM salaries INNER JOIN dept_manager
ON dept_manager.emp_no = salaries.emp_no
AND dept_manager.to_date = '9999-01-01'
AND salaries.to_date = '9999-01-01';
```



## 04查找所有已经分配部门的员工的last_name和first_name

##### 题目描述

CREATE TABLE `dept_emp` (
`emp_no` int(11) NOT NULL,
`dept_no` char(4) NOT NULL,
`from_date` date NOT NULL,
`to_date` date NOT NULL,
PRIMARY KEY (`emp_no`,`dept_no`));
CREATE TABLE `employees` (
`emp_no` int(11) NOT NULL,
`birth_date` date NOT NULL,
`first_name` varchar(14) NOT NULL,
`last_name` varchar(16) NOT NULL,
`gender` char(1) NOT NULL,
`hire_date` date NOT NULL,
PRIMARY KEY (`emp_no`));

##### 输出描述:

```
last_name first_name dept_no
```

- code

```
SELECT employees.last_name,employees.first_name,dept_emp.dept_no
FROM employees INNER JOIN dept_emp
ON employees.`emp_no`=dept_emp.emp_no
```



## 05查找所有员工的last_name和first_name以及对应部门编号dept_no，也包括展示没有分配具体部门的员工

##### 题目描述

查找所有员工的last_name和first_name以及对应部门编号dept_no，也包括展示没有分配具体部门的员工

CREATE TABLE `dept_emp` (
`emp_no` int(11) NOT NULL,
`dept_no` char(4) NOT NULL,
`from_date` date NOT NULL,
`to_date` date NOT NULL,
PRIMARY KEY (`emp_no`,`dept_no`));
CREATE TABLE `employees` (
`emp_no` int(11) NOT NULL,
`birth_date` date NOT NULL,
`first_name` varchar(14) NOT NULL,
`last_name` varchar(16) NOT NULL,
`gender` char(1) NOT NULL,
`hire_date` date NOT NULL,
PRIMARY KEY (`emp_no`));

##### 输出描述

```
last_name first_name dept_no
```

- code

```
select employees.last_name, employees.first_name ,dept_emp.dept_no
from employees left join dept_emp
on dept_emp.emp_no =employees.emp_no
```



## 06查找所有员工入职时候的薪水情况

##### 题目描述

查找所有员工入职时候的薪水情况，给出emp_no以及salary， 并按照emp_no进行逆序
CREATE TABLE `employees` (
`emp_no` int(11) NOT NULL,
`birth_date` date NOT NULL,
`first_name` varchar(14) NOT NULL,
`last_name` varchar(16) NOT NULL,
`gender` char(1) NOT NULL,
`hire_date` date NOT NULL,
PRIMARY KEY (`emp_no`));
CREATE TABLE `salaries` (
`emp_no` int(11) NOT NULL,
`salary` int(11) NOT NULL,
`from_date` date NOT NULL,
`to_date` date NOT NULL,
PRIMARY KEY (`emp_no`,`from_date`));



##### 输出描述:

```
emp_no salary
```

- code

```
SELECT e.emp_no, s.salary FROM employees AS e INNER JOIN salaries AS s
ON e.emp_no = s.emp_no AND e.hire_date = s.from_date
ORDER BY e.emp_no DESC
```



## 07查找薪水涨幅超过15次的员工号emp_no以及其对应的涨幅次数t

## 题目描述

查找薪水涨幅超过15次的员工号emp_no以及其对应的涨幅次数t
CREATE TABLE `salaries` (
`emp_no` int(11) NOT NULL,
`salary` int(11) NOT NULL,
`from_date` date NOT NULL,
`to_date` date NOT NULL,
PRIMARY KEY (`emp_no`,`from_date`));

###### 输出描述：

```
emp_no	t

10001   17
```

```
select emp_no, count(emp_no) as t
from salaries 
group by emp_no 
having t>15
```





## 08找出所有员工当前薪水salary情况

###### 题目描述

找出所有员工当前(to_date='9999-01-01')具体的薪水salary情况，对于相同的薪水只显示一次,并按照逆序显示
CREATE TABLE `salaries` (
`emp_no` int(11) NOT NULL,
`salary` int(11) NOT NULL,
`from_date` date NOT NULL,
`to_date` date NOT NULL,
PRIMARY KEY (`emp_no`,`from_date`));

```
salary
94692
```

```
select distinct salary 
from salaries 
where to_date='9999-01-01'
order by salary desc
```



## 09获取所有部门当前manager的当前薪水情况，给出dept_no, emp_no以及salary，当前表示

###### 题目描述

获取所有部门当前manager的当前薪水情况，给出dept_no, emp_no以及salary，当前表示to_date='9999-01-01'
CREATE TABLE `dept_manager` (
`dept_no` char(4) NOT NULL,
`emp_no` int(11) NOT NULL,
`from_date` date NOT NULL,
`to_date` date NOT NULL,
PRIMARY KEY (`emp_no`,`dept_no`));
CREATE TABLE `salaries` (
`emp_no` int(11) NOT NULL,
`salary` int(11) NOT NULL,
`from_date` date NOT NULL,
`to_date` date NOT NULL,
PRIMARY KEY (`emp_no`,`from_date`));



###### 输出描述:

```
dept_no emp_nos alary
d001     10002  72527
```

```
SELECT dept_no,dept_manager.emp_no,salary
FROM salaries,dept_manager
WHERE salaries.emp_no=dept_manager.emp_no
and salaries.to_date='9999-01-01'
and dept_manager.to_date='9999-01-01'
```





## 10获取所有非manager的员工emp_no

###### 题目描述

获取所有非manager的员工emp_no
CREATE TABLE `dept_manager` (
`dept_no` char(4) NOT NULL,
`emp_no` int(11) NOT NULL,
`from_date` date NOT NULL,
`to_date` date NOT NULL,
PRIMARY KEY (`emp_no`,`dept_no`));
CREATE TABLE `employees` (
`emp_no` int(11) NOT NULL,
`birth_date` date NOT NULL,
`first_name` varchar(14) NOT NULL,
`last_name` varchar(16) NOT NULL,
`gender` char(1) NOT NULL,
`hire_date` date NOT NULL,
PRIMARY KEY (`emp_no`));



###### 输出描述:

```
emp_no

10001
```



```
select employees.emp_no 
from employees left join dept_manager
on employees.emp_no = dept_manager.emp_no
WHERE dept_no IS NULL
```





## 11获取所有员工当前的manager

获取所有员工当前的manager，如果当前的manager是自己的话结果不显示，当前表示to_date='9999-01-01'。
结果第一列给出当前员工的emp_no,第二列给出其manager对应的manager_no。
CREATE TABLE `dept_emp` (
`emp_no` int(11) NOT NULL,
`dept_no` char(4) NOT NULL,
`from_date` date NOT NULL,
`to_date` date NOT NULL,
PRIMARY KEY (`emp_no`,`dept_no`));
CREATE TABLE `dept_manager` (
`dept_no` char(4) NOT NULL,
`emp_no` int(11) NOT NULL,
`from_date` date NOT NULL,
`to_date` date NOT NULL,
PRIMARY KEY (`emp_no`,`dept_no`));

###### 输出描述:

```
emp_no manager_no

10001   10002
```



```
SELECT de.emp_no, dm.emp_no AS manager_no 
FROM dept_emp AS de INNER JOIN dept_manager AS dm
ON de.dept_no = dm.dept_no 
WHERE dm.to_date = '9999-01-01' AND de.to_date = '9999-01-01' AND de.emp_no <> dm.emp_no
```





## 12获取所有部门中当前员工薪水最高的相关信息

###### 题目描述

获取所有部门中当前员工薪水最高的相关信息，给出dept_no, emp_no以及其对应的salary
CREATE TABLE `dept_emp` (
`emp_no` int(11) NOT NULL,
`dept_no` char(4) NOT NULL,
`from_date` date NOT NULL,
`to_date` date NOT NULL,
PRIMARY KEY (`emp_no`,`dept_no`));
CREATE TABLE `salaries` (
`emp_no` int(11) NOT NULL,
`salary` int(11) NOT NULL,
`from_date` date NOT NULL,
`to_date` date NOT NULL,
PRIMARY KEY (`emp_no`,`from_date`));



###### 输出描述:

```
dept_no emp_no salary

d001    10001     88958
```

- code

```
select dept_no, dept_emp.emp_no, max(salary)
from dept_emp inner join salaries
on dept_emp.emp_no = salaries.emp_no
and dept_emp.to_date = '9999-01-01' and salaries.to_date='9999-01-01'
group by dept_no
```



## 13从titles表获取按照title进行分组

###### 题目描述

从titles表获取按照title进行分组，每组个数大于等于2，给出title以及对应的数目t。
CREATE TABLE IF NOT EXISTS "titles" (
`emp_no` int(11) NOT NULL,
`title` varchar(50) NOT NULL,
`from_date` date NOT NULL,
`to_date` date DEFAULT NULL);



###### 输出描述:

```
title				t

Assistant Engineer  2
Engineer			4
```



## 14从titles表获取按照title进行分组，注意对于重复的emp_no进行忽略。

###### 题目描述

从titles表获取按照title进行分组，每组个数大于等于2，给出title以及对应的数目t。
注意对于重复的emp_no进行忽略。
CREATE TABLE IF NOT EXISTS "titles" (
`emp_no` int(11) NOT NULL,
`title` varchar(50) NOT NULL,
`from_date` date NOT NULL,
`to_date` date DEFAULT NULL);



###### 输出描述:

```
title					t

Assistant Engineer		2
Engineer				3
```

```sql
SELECT title, COUNT(DISTINCT emp_no) AS t 
FROM titles
GROUP BY title HAVING t >= 2
```



## 15查找employees表

###### 题目描述

查找employees表所有emp_no为奇数，且last_name不为Mary的员工信息，并按照hire_date逆序排列
CREATE TABLE `employees` (
`emp_no` int(11) NOT NULL,
`birth_date` date NOT NULL,
`first_name` varchar(14) NOT NULL,
`last_name` varchar(16) NOT NULL,
`gender` char(1) NOT NULL,
`hire_date` date NOT NULL,
PRIMARY KEY (`emp_no`));



###### 输出描述:

```
emp_no birth_date first_name last_name gender hire_date

10011 1953-11-07     Mary    Sluis       F    1990-01-22
```

```sql
select * from employees 
where not emp_no %2 =0 
and 
    last_name != 'Mary'
order by hire_date desc
```



## 16统计出当前各个title类型对应的员工当前薪水对应的平均工资

###### 题目描述

统计出当前各个title类型对应的员工当前薪水对应的平均工资。结果给出title以及平均工资avg。
CREATE TABLE `salaries` (
`emp_no` int(11) NOT NULL,
`salary` int(11) NOT NULL,
`from_date` date NOT NULL,
`to_date` date NOT NULL,
PRIMARY KEY (`emp_no`,`from_date`));
CREATE TABLE IF NOT EXISTS "titles" (
`emp_no` int(11) NOT NULL,
`title` varchar(50) NOT NULL,
`from_date` date NOT NULL,
`to_date` date DEFAULT NULL);



###### 输出描述:

```
title			avg	
Engineer		94409.0
Senior Engineer	69009.2
```

```
SELECT titles.title, AVG(salary) as avg
FROM salaries INNER JOIN titles
ON salaries.`emp_no` = titles.emp_no
AND salaries.`to_date`='9999-01-01'
and titles.to_date='9999-01-01'
GROUP BY title 
```





## 17获取当前薪水第二多的员工的emp_no以及其对应的薪水salary

###### 题目描述

获取当前（to_date='9999-01-01'）薪水第二多的员工的emp_no以及其对应的薪水salary
CREATE TABLE `salaries` (
`emp_no` int(11) NOT NULL,
`salary` int(11) NOT NULL,
`from_date` date NOT NULL,
`to_date` date NOT NULL,
PRIMARY KEY (`emp_no`,`from_date`));

###### 输出描述:

```
emp_no	salary
10009	94409
```

```
select emp_no, salary
from salaries
where to_date='9999-01-01'
order by salary desc
limit 1,1
```



## 18获取当前薪水第二多的员工的emp_no以及其对应的薪水salary，不准使用order by

###### 题目描述

查找当前薪水(to_date='9999-01-01')排名第二多的员工编号emp_no、薪水salary、last_name以及first_name，不准使用order by
CREATE TABLE `employees` (
`emp_no` int(11) NOT NULL,
`birth_date` date NOT NULL,
`first_name` varchar(14) NOT NULL,
`last_name` varchar(16) NOT NULL,
`gender` char(1) NOT NULL,
`hire_date` date NOT NULL,
PRIMARY KEY (`emp_no`));
CREATE TABLE `salaries` (
`emp_no` int(11) NOT NULL,
`salary` int(11) NOT NULL,
`from_date` date NOT NULL,
`to_date` date NOT NULL,
PRIMARY KEY (`emp_no`,`from_date`));



###### 输出描述:

```
emp_no	salary	last_name	first_name
10009	94409	Peac		Sumant
```

- code

```
select e.emp_no,max(s.salary),e.last_name,e.first_name 
from employees e, salaries s
where s.salary < (select max(salary) from salaries)
and s.to_date="9999-01-01" 
and e.emp_no=s.emp_no;
```



## 19查找所有员工的last_name和first_name以及对应的dept_name

###### 题目描述

查找所有员工的last_name和first_name以及对应的dept_name，也包括暂时没有分配部门的员工
CREATE TABLE `departments` (
`dept_no` char(4) NOT NULL,
`dept_name` varchar(40) NOT NULL,
PRIMARY KEY (`dept_no`));
CREATE TABLE `dept_emp` (
`emp_no` int(11) NOT NULL,
`dept_no` char(4) NOT NULL,
`from_date` date NOT NULL,
`to_date` date NOT NULL,
PRIMARY KEY (`emp_no`,`dept_no`));
CREATE TABLE `employees` (
`emp_no` int(11) NOT NULL,
`birth_date` date NOT NULL,
`first_name` varchar(14) NOT NULL,
`last_name` varchar(16) NOT NULL,
`gender` char(1) NOT NULL,
`hire_date` date NOT NULL,
PRIMARY KEY (`emp_no`));



###### 输出描述:

```
last_name	first_name	dept_name

Facello		Georgi		Marketing
```

- code

```
SELECT last_name, first_name, departments.dept_name 
FROM employees 
left join dept_emp 
on employees.emp_no=dept_emp.emp_no
left join departments on departments.dept_no = dept_emp.dept_no
```





## 20查找员工编号emp_no为10001其自入职以来的薪水salary涨幅值growth

###### 题目描述

查找员工编号emp_no为10001其自入职以来的薪水salary涨幅值growth
CREATE TABLE `salaries` (
`emp_no` int(11) NOT NULL,
`salary` int(11) NOT NULL,
`from_date` date NOT NULL,
`to_date` date NOT NULL,
PRIMARY KEY (`emp_no`,`from_date`));

###### 输出描述:

```
growth
28841
```

```
select 
(select salary from salaries where emp_no=10001 order by salary desc limit 1)
-
(select salary from salaries where emp_no=10001 order by salary asc limit 1)
as growth
```





## 21查找所有员工自入职以来的薪水涨幅情况

###### 题目描述

查找所有员工自入职以来的薪水涨幅情况，给出员工编号emp_no以及其对应的薪水涨幅growth，并按照growth进行升序
CREATE TABLE `employees` (
`emp_no` int(11) NOT NULL,
`birth_date` date NOT NULL,
`first_name` varchar(14) NOT NULL,
`last_name` varchar(16) NOT NULL,
`gender` char(1) NOT NULL,
`hire_date` date NOT NULL,
PRIMARY KEY (`emp_no`));
CREATE TABLE `salaries` (
`emp_no` int(11) NOT NULL,
`salary` int(11) NOT NULL,
`from_date` date NOT NULL,
`to_date` date NOT NULL,
PRIMARY KEY (`emp_no`,`from_date`));



###### 输出描述:

```
emp_no	growth

10011	0
```



```sql
select cur.emp_no, 
(cur.salary-st.salary) as growth
from (select e.emp_no, s.salary from employees e , salaries s where e.emp_no=s.emp_no and s.to_date= '9999-01-01') as cur,
(select e.emp_no, s.salary from employees e, salaries s where e.emp_no=s.emp_no and s.from_date=e.hire_date) as st
where cur.emp_no = st.emp_no
order by growth
```



## 22统计各个部门对应员工涨幅的次数总和

###### 题目描述

统计各个部门对应员工涨幅的次数总和，给出部门编码dept_no、部门名称dept_name以及次数sum
CREATE TABLE `departments` (
`dept_no` char(4) NOT NULL,
`dept_name` varchar(40) NOT NULL,
PRIMARY KEY (`dept_no`));
CREATE TABLE `dept_emp` (
`emp_no` int(11) NOT NULL,
`dept_no` char(4) NOT NULL,
`from_date` date NOT NULL,
`to_date` date NOT NULL,
PRIMARY KEY (`emp_no`,`dept_no`));
CREATE TABLE `salaries` (
`emp_no` int(11) NOT NULL,
`salary` int(11) NOT NULL,
`from_date` date NOT NULL,
`to_date` date NOT NULL,
PRIMARY KEY (`emp_no`,`from_date`));



###### 输出描述:

```
dept_no		dept_name	sum

d001		Marketing	24
d002		Finance		14
```

```sql

select d.dept_no ,dept.dept_name,count(salary) from salaries s ,dept_emp d,departments dept
where s.emp_no = d.emp_no and d.dept_no=dept.dept_no group by dept.dept_no
```





## 23对所有员工的薪水按照salary进行按照1-N的排名

###### 题目描述

对所有员工的当前(to_date='9999-01-01')薪水按照salary进行按照1-N的排名，相同salary并列且按照emp_no升序排列
CREATE TABLE `salaries` (
`emp_no` int(11) NOT NULL,
`salary` int(11) NOT NULL,
`from_date` date NOT NULL,
`to_date` date NOT NULL,
PRIMARY KEY (`emp_no`,`from_date`));



###### 输出描述:

```
emp_no	salary	rank

10005	94692	1
```

```sql
SELECT s1.emp_no, s1.salary, COUNT(DISTINCT s2.salary) AS rank
FROM salaries AS s1, salaries AS s2
WHERE s1.to_date = '9999-01-01'  AND s2.to_date = '9999-01-01' AND s1.salary <= s2.salary
GROUP BY s1.emp_no
ORDER BY s1.salary DESC, s1.emp_no ASC
```



## 24获取所有非manager员工当前的薪水情况

###### 题目描述

获取所有非manager员工当前的薪水情况，给出dept_no、emp_no以及salary ，当前表示to_date='9999-01-01'
CREATE TABLE `dept_emp` (
`emp_no` int(11) NOT NULL,
`dept_no` char(4) NOT NULL,
`from_date` date NOT NULL,
`to_date` date NOT NULL,
PRIMARY KEY (`emp_no`,`dept_no`));
CREATE TABLE `dept_manager` (
`dept_no` char(4) NOT NULL,
`emp_no` int(11) NOT NULL,
`from_date` date NOT NULL,
`to_date` date NOT NULL,
PRIMARY KEY (`emp_no`,`dept_no`));
CREATE TABLE `employees` (
`emp_no` int(11) NOT NULL,
`birth_date` date NOT NULL,
`first_name` varchar(14) NOT NULL,
`last_name` varchar(16) NOT NULL,
`gender` char(1) NOT NULL,
`hire_date` date NOT NULL,
PRIMARY KEY (`emp_no`));
CREATE TABLE `salaries` (
`emp_no` int(11) NOT NULL,
`salary` int(11) NOT NULL,
`from_date` date NOT NULL,
`to_date` date NOT NULL,
PRIMARY KEY (`emp_no`,`from_date`));



###### 输出描述:

```
dept_no	emp_no	salary

d001	10001	88958
d004	10003	43311
d005	10007	88070
```



```sql
select d.dept_no,d.emp_no,s.salary 
from dept_emp d inner join salaries s
on d.emp_no = s.emp_no 
where d.to_date= '9999-01-01' and s.to_date='9999-01-01' 
and d.emp_no not in (select emp_no from dept_manager ) 
```



## 25获取员工其当前的薪水比其manager当前薪水还高的相关信息

###### 题目描述

获取员工其当前的薪水比其manager当前薪水还高的相关信息，当前表示to_date='9999-01-01',
结果第一列给出员工的emp_no，
第二列给出其manager的manager_no，
第三列给出该员工当前的薪水emp_salary,
第四列给该员工对应的manager当前的薪水manager_salary
CREATE TABLE `dept_emp` (
`emp_no` int(11) NOT NULL,
`dept_no` char(4) NOT NULL,
`from_date` date NOT NULL,
`to_date` date NOT NULL,
PRIMARY KEY (`emp_no`,`dept_no`));
CREATE TABLE `dept_manager` (
`dept_no` char(4) NOT NULL,
`emp_no` int(11) NOT NULL,
`from_date` date NOT NULL,
`to_date` date NOT NULL,
PRIMARY KEY (`emp_no`,`dept_no`));
CREATE TABLE `salaries` (
`emp_no` int(11) NOT NULL,
`salary` int(11) NOT NULL,
`from_date` date NOT NULL,
`to_date` date NOT NULL,
PRIMARY KEY (`emp_no`,`from_date`));



###### 输出描述:

```
emp_no	manager_no	emp_salary	manager_salary

10001	10002		88958		72527
10009	10010		95409		94409
```

```sql
SELECT a.emp_no AS emp_no, b.emp_no AS manager_no, a.salary AS emp_salary, b.salary AS manager_salary
FROM (SELECT s.salary, s.emp_no, de.dept_no FROM salaries s INNER JOIN dept_emp de
ON s.emp_no = de.emp_no AND s.to_date = '9999-01-01' ) AS a, 
(SELECT s.salary, s.emp_no, dm.dept_no FROM salaries s INNER JOIN dept_manager dm
ON s.emp_no = dm.emp_no AND s.to_date = '9999-01-01' ) AS b
WHERE a.dept_no = b.dept_no AND a.salary > b.salary
```



## 26汇总各个部门当前员工的title类型的分配数目

###### 题目描述

汇总各个部门当前员工的title类型的分配数目，结果给出部门编号dept_no、dept_name、其当前员工所有的title以及该类型title对应的数目count
CREATE TABLE `departments` (
`dept_no` char(4) NOT NULL,
`dept_name` varchar(40) NOT NULL,
PRIMARY KEY (`dept_no`));
CREATE TABLE `dept_emp` (
`emp_no` int(11) NOT NULL,
`dept_no` char(4) NOT NULL,
`from_date` date NOT NULL,
`to_date` date NOT NULL,
PRIMARY KEY (`emp_no`,`dept_no`));
CREATE TABLE IF NOT EXISTS `titles` (
`emp_no` int(11) NOT NULL,
`title` varchar(50) NOT NULL,
`from_date` date NOT NULL,
`to_date` date DEFAULT NULL);



###### 输出描述:

```
dept_no	dept_name	title			count

d001	Marketing	Senior Engineer	1
d001	Marketing	Staff			1
```

- code

```sql
select de.dept_no,dp.dept_name,t.title,count(t.title) as `count`
from departments dp inner join dept_emp de
on dp.dept_no = de.dept_no and de.to_date='9999-01-01'
inner join titles t
on t.emp_no = de.emp_no and t.to_date = '9999-01-01'
group by de.dept_no,t.title
```





## 27给出每个员工每年薪水涨幅超过5000的员工编号emp_no

###### 题目描述

给出每个员工每年薪水涨幅超过5000的员工编号emp_no、薪水变更开始日期from_date以及薪水涨幅值salary_growth，并按照salary_growth逆序排列。

提示：在sqlite中获取datetime时间对应的年份函数为strftime('%Y', to_date)

CREATE TABLE `salaries` (

`emp_no` int(11) NOT NULL,

`salary` int(11) NOT NULL,

`from_date` date NOT NULL,

`to_date` date NOT NULL,

PRIMARY KEY (`emp_no`,`from_date`));



###### 输出描述:

```
emp_no	from_date	salary_growth
10003	1995-12-03	24178
10008	1998-03-11	20843
```

- code

```sql
select s1.emp_no, s1.from_date, (s1.salary-s2.salary) salary_growth
from salaries s1 
inner join salaries s2
on s1.emp_no = s2.emp_no
where s1.salary -s2.salary>5000
and strftime('%Y', s1.to_date) -strftime('%Y', s2.to_date)=1
order by salary_growth desc;
```





## 28查找描述信息中包括robot的电影对应的分类名称以及电影数目，而且还需要该分类对应电影数量

###### 题目描述

film表

| 字段        | 说明         |
| ----------- | ------------ |
| film_id     | 电影id       |
| title       | 电影名称     |
| description | 电影描述信息 |

> CREATE TABLE IF NOT EXISTS film (
>
> film_id smallint(5)  NOT NULL DEFAULT '0',
>
> title varchar(255) NOT NULL,
>
> description text,
>
> PRIMARY KEY (film_id));

category表

| 字段        | 说明                 |
| ----------- | -------------------- |
| category_id | 电影分类id           |
| name        | 电影分类名称         |
| last_update | 电影分类最后更新时间 |

> CREATE TABLE category  (
>
> category_id  tinyint(3)  NOT NULL ,
>
> name  varchar(25) NOT NULL, `last_update` timestamp,
>
> PRIMARY KEY ( category_id ));

film_category表

| 字段        | 说明                                 |
| ----------- | ------------------------------------ |
| film_id     | 电影id                               |
| category_id | 电影分类id                           |
| last_update | 电影id和分类id对应关系的最后更新时间 |

> CREATE TABLE film_category  (
>
> film_id  smallint(5)  NOT NULL,
>
> category_id  tinyint(3)  NOT NULL, `last_update` timestamp);



查找描述信息中包括robot的电影对应的分类名称以及电影数目，而且还需要该分类对应电影数量>=5部



```sql
select c.name,count(fc.film_id)
from (
    select category_id,count(category_id)
    from film_category
    group by category_id
    having count(category_id)>=5
)as cc,
film_category fc,
category c,
film f
where f.description like '%robot%'
and f.film_id = fc.film_id
AND c.category_id = fc.category_id
AND c.category_id = cc.category_id;
```





## 29使用join查询方式找出没有分类的电影id以及名称

###### 题目描述

film表

| 字段        | 说明         |
| ----------- | ------------ |
| film_id     | 电影id       |
| title       | 电影名称     |
| description | 电影描述信息 |

> CREATE TABLE IF NOT EXISTS film (
>
> film_id smallint(5)  NOT NULL DEFAULT '0',
>
> title varchar(255) NOT NULL,
>
> description text,
>
> PRIMARY KEY (film_id));

category表

| 字段        | 说明                 |
| ----------- | -------------------- |
| category_id | 电影分类id           |
| name        | 电影分类名称         |
| last_update | 电影分类最后更新时间 |

> CREATE TABLE category  (
>
> category_id  tinyint(3)  NOT NULL ,
>
> name  varchar(25) NOT NULL, `last_update` timestamp,
>
> PRIMARY KEY ( category_id ));

film_category表

| 字段        | 说明                                 |
| ----------- | ------------------------------------ |
| film_id     | 电影id                               |
| category_id | 电影分类id                           |
| last_update | 电影id和分类id对应关系的最后更新时间 |

> CREATE TABLE film_category  (
>
> film_id  smallint(5)  NOT NULL,
>
> category_id  tinyint(3)  NOT NULL, `last_update` timestamp);



使用join查询方式找出没有分类的电影id以及名称



```sql
select f.film_id, f.title
from film f
left join film_category c
on f.film_id = c.film_id
where c.category_id is null;
```





## 29使用子查询的方式找出属于Action分类的所有电影对应的title,description

###### 题目描述

film表

| 字段        | 说明         |
| ----------- | ------------ |
| film_id     | 电影id       |
| title       | 电影名称     |
| description | 电影描述信息 |

> CREATE TABLE IF NOT EXISTS film (
>
> film_id smallint(5)  NOT NULL DEFAULT '0',
>
> title varchar(255) NOT NULL,
>
> description text,
>
> PRIMARY KEY (film_id));

category表

| 字段        | 说明                 |
| ----------- | -------------------- |
| category_id | 电影分类id           |
| name        | 电影分类名称         |
| last_update | 电影分类最后更新时间 |

> CREATE TABLE category  (
>
> category_id  tinyint(3)  NOT NULL ,
>
> name  varchar(25) NOT NULL, `last_update` timestamp,
>
> PRIMARY KEY ( category_id ));

film_category表

| 字段        | 说明                                 |
| ----------- | ------------------------------------ |
| film_id     | 电影id                               |
| category_id | 电影分类id                           |
| last_update | 电影id和分类id对应关系的最后更新时间 |

> CREATE TABLE film_category  (
>
> film_id  smallint(5)  NOT NULL,
>
> category_id  tinyint(3)  NOT NULL, `last_update` timestamp);



使用子查询的方式找出属于Action分类的所有电影对应的title,description



```
select f.title,f.description
from film  f 
inner join film_category fc on f.film_id=fc.film_id
inner join category c on c.category_id= fc.category_id
where c.name = 'Action'
```



## 30获取select * from employees对应的执行计划

```
explain select * from employees
```





## 31将employees表的所有员工的last_name和first_name拼接起来作为Name

###### 题目描述

将employees表的所有员工的last_name和first_name拼接起来作为Name，中间以一个空格区分
CREATE TABLE `employees` ( `emp_no` int(11) NOT NULL,
`birth_date` date NOT NULL,
`first_name` varchar(14) NOT NULL,
`last_name` varchar(16) NOT NULL,
`gender` char(1) NOT NULL,
`hire_date` date NOT NULL,
PRIMARY KEY (`emp_no`));



###### 输出描述:

| name           |
| -------------- |
| Facello Georgi |
| Simmel Bezalel |
| Bamford Parto  |

- code

```
select last_name||" "||first_name AS Name FROM employees;
```





## 32创建一个actor表，包含如下列信息

## 题目描述

创建一个actor表，包含如下列信息

| 列表        | 类型        | 是否为NULL | 含义                               |
| ----------- | ----------- | ---------- | ---------------------------------- |
| actor_id    | smallint(5) | not null   | 主键id                             |
| first_name  | varchar(45) | not null   | 名字                               |
| last_name   | varchar(45) | not null   | 姓氏                               |
| last_update | timestamp   | not null   | 最后更新时间，默认是系统的当前时间 |



- cod

```
create table actor(
actor_id smallint(5) not null PRIMARY key,
first_name varchar(45) not null ,
last_name varchar(45) not null,
last_update timestamp not null DEFAULT (datetime('now','localtime')) 
)
```



## 33批量插入数据

###### 题目描述

对于表actor批量插入如下数据

CREATE TABLE IF NOT EXISTS actor (

actor_id smallint(5) NOT NULL PRIMARY KEY,

first_name varchar(45) NOT NULL,

last_name varchar(45) NOT NULL,

last_update timestamp NOT NULL DEFAULT (datetime('now','localtime')))

| actor_id | first_name | last_name | last_update         |
| -------- | ---------- | --------- | ------------------- |
| 1        | PENELOPE   | GUINESS   | 2006-02-15 12:34:33 |
| 2        | NICK       | WAHLBERG  | 2006-02-15 12:34:33 |

- code

```sql
insert into actor
values(1,'PENELOPE','GUINESS','2006-02-15 12:34:33'),(2,'NICK','WAHLBERG','2006-02-15 12:34:33');
```



## 34批量插入数据，不使用replace操作

## 题目描述

对于表actor批量插入如下数据,如果数据已经存在，请忽略，不使用replace操作

CREATE TABLE IF NOT EXISTS actor (

actor_id smallint(5) NOT NULL PRIMARY KEY,

first_name varchar(45) NOT NULL,

last_name varchar(45) NOT NULL,

last_update timestamp NOT NULL DEFAULT (datetime('now','localtime')))

| actor_id | first_name | last_name | last_update           |
| -------- | ---------- | --------- | --------------------- |
| '3'      | 'ED'       | 'CHASE'   | '2006-02-15 12:34:33' |

- code

```
insert or ignore into actor
values('3','ED','CHASE','2006-02-15 12:34:33')
```



## 35创建一个actor_name表

###### 题目描述

对于如下表actor，其对应的数据为:

| actor_id | first_name | last_name | last_update         |
| -------- | ---------- | --------- | ------------------- |
| 1        | PENELOPE   | GUINESS   | 2006-02-15 12:34:33 |
| 2        | NICK       | WAHLBERG  | 2006-02-15 12:34:33 |

创建一个actor_name表，将actor表中的所有first_name以及last_name导入改表。 actor_name表结构如下：

| 列表       | 类型        | 是否为NULL | 含义 |
| ---------- | ----------- | ---------- | ---- |
| first_name | varchar(45) | not null   | 名字 |
| last_name  | varchar(45) | not null   | 姓氏 |



- code

```
create table actor_name as
select first_name,last_name from actor
```



## 36对first_name创建唯一索引uniq_idx_firstname

###### 题目描述

针对如下表actor结构创建索引：
CREATE TABLE IF NOT EXISTS actor (
actor_id smallint(5) NOT NULL PRIMARY KEY,
first_name varchar(45) NOT NULL,
last_name varchar(45) NOT NULL,
last_update timestamp NOT NULL DEFAULT (datetime('now','localtime')))
对first_name创建唯一索引uniq_idx_firstname，对last_name创建普通索引idx_lastname

- code

```
create unique index uniq_idx_firstname on actor(first_name);
create index idx_lastname on actor(last_name)
```



## 37针对actor表创建视图actor_name_view

> 针对actor表创建视图actor_name_view，只包含first_name以及last_name两列，并对这两列重新命名，first_name为first_name_v，last_name修改为last_name_v：
> CREATE TABLE IF NOT EXISTS actor (
> actor_id smallint(5) NOT NULL PRIMARY KEY,
> first_name varchar(45) NOT NULL,
> last_name varchar(45) NOT NULL,
> last_update timestamp NOT NULL DEFAULT (datetime('now','localtime')))

```
create view actor_name_view (first_name_v,last_name_v) as
select first_name,last_name from actor
```



## 38针对上面的salaries表emp_no字段创建索引idx_emp_no

> 题目描述：
>
> 针对salaries表emp_no字段创建索引idx_emp_no，查询emp_no为10005, 使用强制索引。
> CREATE TABLE `salaries` (
> `emp_no` int(11) NOT NULL,
> `salary` int(11) NOT NULL,
> `from_date` date NOT NULL,
> `to_date` date NOT NULL,
> PRIMARY KEY (`emp_no`,`from_date`));
> create index idx_emp_no on salaries(emp_no);



```sql
#sqlite
SELECT * FROM salaries INDEXED BY idx_emp_no WHERE emp_no = 10005
#mysql--查询时强制使用索引方式
SELECT * FROM salaries FORCE INDEX idx_emp_no WHERE emp_no = 10005
```



## 60统计salary的累计和running_total

> 题目描述：
>
> 按照salary的累计和running_total，其中running_total为前两个员工的salary累计和，其他以此类推。 具体结果如下Demo展示。。

CREATE TABLE `salaries` ( `emp_no` int(11) NOT NULL,

`salary` int(11) NOT NULL,

`from_date` date NOT NULL,

`to_date` date NOT NULL,

PRIMARY KEY (`emp_no`,`from_date`));

输出格式:

| emp_no | salary | running_total |
| ------ | ------ | ------------- |
| 10001  | 88958  | 88958         |
| 10002  | 72527  | 161485        |
| 10003  | 43311  | 204796        |
| 10004  | 74057  | 278853        |
| 10005  | 94692  | 373545        |
| 10006  | 43311  | 416856        |
| 10007  | 88070  | 504926        |
| 10009  | 95409  | 600335        |



```sqlite
select s1.emp_no, s1.salary,  (select sum(s2.salary) from salaries as s2 where s2.emp_no<= s1.emp_no AND s2.to_date='9999-01-01'  ) as  running_total from 
salaries s1 where s1.to_date='9999-01-01' order by s1.emp_no 

```



## 61对于employees表中，给出奇数行的first_name

## 题目描述

> 对于employees表中，给出奇数行的first_name
>
> CREATE TABLE `employees` (
>
> `emp_no` int(11) NOT NULL,
>
> `birth_date` date NOT NULL,
>
> `first_name` varchar(14) NOT NULL,
>
> `last_name` varchar(16) NOT NULL,
>
> `gender` char(1) NOT NULL,
>
> `hire_date` date NOT NULL,
>
> PRIMARY KEY (`emp_no`));



输出格式:

| first_name |
| ---------- |
| Georgi     |
| Chirstian  |
| Anneke     |
| Tzvetan    |
| Saniya     |
| Mary       |

```sqlite
SELECT e1.first_name FROM 
  (SELECT e2.first_name, 
    (SELECT COUNT(*) FROM employees AS e3 
     WHERE e3.first_name <= e2.first_name) 
   AS rowid FROM employees AS e2) AS e1
WHERE e1.rowid % 2 = 1
```







# LeetCode database

## 175Combine Two Tables

> Write a SQL query for a report that provides the following information for each person in the Person table, regardless if there is an address for each of those people:

```
select Person.FirstName,Person.LastName,Address.City,Address.State
from Person
left  join Address
on Person.PersonId = Address.PersonId
```



## 176Second Highest Salary

> For example, given the above Employee table, the query should return `200` as the second highest salary. If there is no second highest salary, then the query should return `null`.

```
SELECT IFNULL(SELECT Salary FROM Employee GROUP BY Salary ORDER BY Salary DESC LIMIT 1,1),
NULL) AS SecondHighestSalary
```



## 177 Nth Highest Salary

获取第n高的薪水

```
CREATE FUNCTION getNthHighestSalary(N INT) RETURNS INT
BEGIN
    DECLARE n1 INT;
    SET n1=N-1;  
  RETURN (
      SELECT Salary FROM 
      (SELECT DISTINCT Salary FROM Employee) t 
      ORDER BY Salary DESC 
      LIMIT n1,1

  );
END
```





